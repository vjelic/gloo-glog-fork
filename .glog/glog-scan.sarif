{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "70fb2565-7708-3f75-90cc-bd0da2a734fc",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are derived from related data structures, and dataflow analysis suggests that they may refer to overlapping memory. Additionally, the source may be null at this call site, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the function does not ensure that the source and destination are distinct or valid. These factors indicate a real risk of memory corruption or program crashes if the overlap or null pointer dereference occurs.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, validate that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n**Remediation Example:**\n\n```cpp\n// Check for null source and use memmove for possible overlap\nif (inbox_[chunkOffset & 1] != nullptr) {\n    memmove(&ptrs_[0][offset], inbox_[chunkOffset & 1], length * sizeof(T));\n}\n// Optionally, handle the error case if the source is null\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "03e0fab1-b339-3b6d-8a5a-0eb97d3704e8",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the destination and source pointers may refer to overlapping memory areas, which is not allowed for the memcpy function and can result in unpredictable program behavior. Additionally, the analysis could not rule out the possibility that the source pointer may be null, which would also cause undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the verdict confirms this is a high-confidence finding. Developers should ensure that the source and destination do not overlap and are valid before performing the memory copy.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before copying.\n\n```cpp\nif (ptrs_[i] != nullptr && ptrs_[0] != nullptr &&\n    (ptrs_[i] + bytes_ <= ptrs_[0] || ptrs_[0] + bytes_ <= ptrs_[i])) {\n    memcpy(ptrs_[i], ptrs_[0], bytes_);\n} else if (ptrs_[i] != nullptr && ptrs_[0] != nullptr) {\n    // Safe fallback for overlapping regions\n    memmove(ptrs_[i], ptrs_[0], bytes_);\n}\n```\n\nThis code first checks that both pointers are not null and that the memory regions do not overlap before using `memcpy`. If overlap is detected, it uses `memmove` as a safe alternative.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ec005ff6-7e92-366d-b865-51282adf062a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions in a memory copy operation. The destination and source pointers may refer to overlapping memory, as indicated by the data flow analysis. Additionally, the source pointer may be null, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues. The classification and verdict both indicate a high-confidence, actionable issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(ptrs_[i], ptrs_[0], bytes_);\n```\n\nAdditionally, ensure that both `ptrs_[i]` and `ptrs_[0]` are valid, non-null pointers before performing the operation to avoid null pointer dereference. For example:\n\n```cpp\nif (ptrs_[i] != nullptr && ptrs_[0] != nullptr) {\n    memmove(ptrs_[i], ptrs_[0], bytes_);\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "6c86517b-7edb-3fc1-b7cd-cd26cf5b2d5d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(data.get(), &t, sizeof(T))`, there is no check to ensure that the size of `T` is not larger than the size of the buffer pointed to by `data.get()`. If `T` is larger, this could lead to a buffer overflow, which could potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`. If the data is too large, you should handle this error condition appropriately, for example by truncating the data or by allocating a larger buffer.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code snippet:\n\n```cpp\nif (sizeof(T) <= data.size()) {\n    memcpy(data.get(), &t, sizeof(T));\n} else {\n    // Handle error condition here\n}\n```\n\nIn this fixed code, we first check if the size of `T` is less than or equal to the size of the buffer. If it is, we proceed with the `memcpy`. If it is not, we handle the error condition.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "b42dc0bb-aaf4-31da-96ac-52e576a75c3c",
              "name": "Win32HardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol: Win32 - Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440077"
                ]
              }
            },
            {
              "id": "7bdbca30-24e7-327c-99e4-879c4effe401",
              "name": "Win32HardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol: Win32 - Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440077"
                ]
              }
            },
            {
              "id": "e7aa8d31-6ac7-3e92-9c9b-7a898e06ce46",
              "name": "Win32HardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol: Win32 - Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440077"
                ]
              }
            },
            {
              "id": "9c81a934-9274-35e2-b307-e5c625e3cee4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen` will continue reading memory beyond the intended boundary, leading to a buffer overflow. This can cause crashes, incorrect behavior, or even allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Be careful when manipulating strings, especially when using functions like `strcpy` or `strcat` that can overwrite the null terminator. Also, consider using safer alternatives to `strlen` that take a maximum length parameter, such as `strnlen`.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```c++\nlen = strlen(str);\n```\n\nYou could use:\n\n```c++\nlen = strnlen(str, MAX_LEN);\n```\n\nWhere `MAX_LEN` is the maximum expected length of the string. This will prevent `strnlen` from reading beyond this limit, even if `str` is not null-terminated.\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library, so no additional libraries are needed. The `strnlen` function is part of the POSIX library, so it may not be available on non-POSIX systems.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "1f9f821c-e4b5-33c2-9bf2-09a7a880046e",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, both the source and destination pointers may be null at this call site, and there are no explicit guards to prevent this. The use of a direct memory copy function without overlap protection in such a scenario can lead to unpredictable program behavior, crashes, or security vulnerabilities. The absence of explicit bounds checks or null pointer guards further increases the risk.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use a function that is safe for overlapping memory, such as `memmove`, instead of `memcpy`. Additionally, ensure that both the source and destination pointers are not null before performing the copy operation. For example:\n\n```cpp\nif (bytes.data() != nullptr && &impl_ != nullptr) {\n    memmove(bytes.data(), &impl_, sizeof(impl_));\n}\n```\nThis change ensures that the copy operation is safe even if the source and destination overlap, and avoids dereferencing null pointers.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "2c388ac3-2043-37e1-bbf4-c45099d777bf",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is a risk that the source pointer could be null at runtime, since there is no prior check ensuring it is valid. The destination is not likely to be null, but the overlap and null source risks make this a high-confidence issue. The operation does not include any explicit bounds or null-termination handling, and the use of memcpy in this context can lead to unpredictable results or crashes if the overlap occurs.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\nExample remediation:\n\n```cpp\nif (bytes.data() != nullptr) {\n    memmove(&impl_, bytes.data(), sizeof(impl_));\n}\n```\n\nThis change replaces `memcpy` with `memmove` and adds a null check for the source pointer. This ensures safe copying even if the memory regions overlap and prevents undefined behavior due to a null source pointer.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e7ce36cb-52aa-3534-ac0c-f07a093e4fc2",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. Specifically, there is evidence that the source and destination pointers may refer to overlapping memory (an alias assignment was observed), which is not allowed for the memcpy function and can result in unpredictable program behavior. The destination and source pointers are both checked to be non-null before the call, reducing the risk of null pointer dereference, but the overlap risk remains. The count argument is not directly derived from the destination's capacity, and there is no explicit guard or null-termination after the copy. This combination of factors makes the issue actionable and not a likely false positive.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to safely handle overlapping memory. This change ensures that the copy operation is well-defined even if the source and destination regions overlap.\n\n```cpp\nmemmove(out->ptr, in->ptr, opts.elements * opts.elementSize);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "5b00e094-edfe-357c-b47f-652de84cbe24",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions in the code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. In the case of `strerror()`, a safer alternative is `strerror_r()`, which is thread-safe.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with `strerror_r()` in the code snippet:\n\n```cpp\nchar buf[1024];\nstrerror_r(errno, buf, sizeof(buf));\nsignalException(GLOO_ERROR_MSG(\"accept: \", buf))\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<cstring>`: for `strerror_r()`\n- `<cerrno>`: for `errno`\n- `<gloo/error.h>`: for `GLOO_ERROR_MSG()`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "381bd970-92bd-323f-a7e7-271694942b0e",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using insecure and non-thread-safe C library functions. Instead, use their secure alternatives that are provided in the C++ Standard Library. For instance, instead of `strerror()`, use `strerror_s()` or `strerror_r()`, which are thread-safe.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with `strerror_s()` or `strerror_r()`. Here is how you can do it:\n\n```cpp\nchar buf[256];\nstrerror_s(buf, sizeof buf, optval);\nGLOO_ERROR_MSG(\"connect \", peer_.str(), \": \", buf);\n```\n\nor\n\n```cpp\nchar buf[256];\nstrerror_r(optval, buf, sizeof buf);\nGLOO_ERROR_MSG(\"connect \", peer_.str(), \": \", buf);\n```\n\n## Library Dependencies\n\nThe code snippet seems to be using the Gloo library for collective communications. Therefore, the Gloo library is required for the code to execute properly.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "8ac08341-5db8-35f2-8733-b389f4b676e8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are considered insecure because they do not perform bounds checking and other necessary validations, which can lead to buffer overflow attacks, format string vulnerabilities, and other security issues. In the provided code snippet, the `strerror` function is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure alternatives to these insecure C library functions. For instance, instead of using `strerror`, you can use `strerror_r` or `strerror_s` which are thread-safe. Also, consider using C++ standard library functions and classes that provide the necessary bounds checking and validation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nchar buf[1024];\nif (strerror_r(errno, buf, sizeof(buf)) != 0) {\n    buf[0] = '\\0';  // Fallback\n}\nGLOO_ERROR_MSG(\"Read error \", peer_.str(), \": \", buf);\n```\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `<cstring>`: for `strerror` function\n- `<cerrno>`: for `errno`\n\n## OWASP and CWE Links\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that these links are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "6b665f15-2f96-3e9c-9ae1-251cbd1bc4a3",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `strerror()` is used which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives like `strerror_r()` in POSIX or `strerror_s()` in Windows. Also, consider using higher-level abstractions provided by the C++ Standard Library, which are usually safer and less error-prone.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with its thread-safe counterpart `strerror_r()`:\n\n```cpp\nchar buf[1024];\nstrerror_r(errno, buf, sizeof(buf));\nsignalAndThrowException(GLOO_ERROR_MSG(\"connect: \", buf));\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstring` for `strerror()`\n- `cerrno` for `errno`\n- `Gloo` for `GLOO_ERROR_MSG()`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "b4bd9cde-a788-3ebf-92a7-4a9d2e82495d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `strerror` is used which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror`. Instead, use thread-safe alternatives like `strerror_r` (in POSIX) or `strerror_s` (in Windows). Also, consider using higher-level abstractions provided by the C++ Standard Library, which are usually safer and less error-prone.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror` function with its thread-safe counterpart `strerror_r`:\n\n```cpp\nchar buf[1024];\nstrerror_r(errno, buf, sizeof(buf));\nGLOO_ERROR_MSG(\"writev \", peer_.str(), \": \", buf);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstring` for `strerror` or `strerror_r`\n- `cerrno` for `errno`\n- `gloo` for `GLOO_ERROR_MSG`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "7c6b43d4-d76c-367c-b952-eef692ba8dd3",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives like `strerror_r()` in POSIX or `strerror_s()` in Windows. Also, consider using higher-level abstractions provided by the C++ Standard Library, which are usually safer and less error-prone.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with its thread-safe counterpart `strerror_r()`:\n\n```cpp\nchar buf[1024];\nstrerror_r(errno, buf, sizeof(buf));\nsignalAndThrowException(GLOO_ERROR_MSG(\"socket: \", buf));\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstring` for `strerror()`\n- `cerrno` for `errno`\n- `Gloo` for `GLOO_ERROR_MSG()`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "fd75822b-078f-325a-bede-4725e9d9e9d8",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives like `strerror_r()` in POSIX or `strerror_s()` in Windows. Also, consider using higher-level abstractions provided by the C++ Standard Library or other libraries that are designed with safety in mind.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with its thread-safe counterpart `strerror_r()`:\n\n```cpp\nchar buf[1024];\nstrerror_r(errno, buf, sizeof(buf));\nsignalAndThrowException(GLOO_ERROR_MSG(\"setsockopt: \", buf));\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstring` for `strerror()`\n- `cerrno` for `errno`\n- `Gloo` for `GLOO_ERROR_MSG()`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "01432ad5-0c92-36cc-90c5-ed6faab06a4f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives like `strerror_r()` in POSIX or `strerror_s()` in Windows. Also, consider using higher-level abstractions provided by the C++ Standard Library, which are usually safer and less error-prone.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with its thread-safe counterpart `strerror_r()`:\n\n```cpp\nchar buf[1024];\nstrerror_r(errno, buf, sizeof(buf));\nsignalAndThrowException(GLOO_ERROR_MSG(\"socket: \", buf));\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstring` for `strerror()`\n- `cerrno` for `errno`\n- `Gloo` for `GLOO_ERROR_MSG()`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "1335673f-b0fc-3092-b762-9d794e45e49a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives like `strerror_r()` in POSIX or `strerror_s()` in Windows. Also, consider using higher-level abstractions provided by the C++ Standard Library, which are usually safer and less error-prone.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with its thread-safe counterpart `strerror_r()`:\n\n```cpp\nchar buf[1024];\nif (strerror_r(errno, buf, sizeof(buf)) != 0) {\n    // handle error\n}\nsignalAndThrowException(GLOO_ERROR_MSG(\"listen: \", buf))\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstring` for `strerror()`\n- `cerrno` for `errno`\n- `Gloo` for `GLOO_ERROR_MSG()`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "6274f92c-0f62-3b0b-b06f-38daa190c1ec",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives like `strerror_r()` in POSIX or `strerror_s()` in Windows. Also, consider using higher-level abstractions provided by the C++ Standard Library or other libraries that are designed with safety in mind.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with its thread-safe counterpart `strerror_r()`:\n\n```cpp\nchar buf[1024];\nstrerror_r(errno, buf, sizeof(buf));\nsignalAndThrowException(GLOO_ERROR_MSG(\"setsockopt: \", buf));\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstring` for `strerror()`\n- `cerrno` for `errno`\n- `Gloo` for `GLOO_ERROR_MSG()`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "2b40bb5d-1968-3b6a-8a40-8205f153de55",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The source and destination pointers are derived from the same array or data structure, and dataflow analysis suggests that they may refer to overlapping memory areas. Additionally, the source pointer may be null, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the classification and verdict both indicate a high-confidence, actionable problem.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely, whereas `memcpy` is not. Replace the original call with:\n\n```cpp\nmemmove(ptrs_[i], ptrs_[0], bytes_);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "65e652d8-a70b-399d-8aa8-6532ada9c672",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions. The analysis detected that both the source and destination are members of the same object (indicated by 'same base identifier: this'), which increases the likelihood of overlap. Additionally, there are no explicit checks ensuring that the source and destination pointers are non-null, which further increases the risk of undefined behavior. The verdict for this call site is marked as 'GENUINE', confirming the high confidence in this issue. No evidence was found to suggest that this is a false positive, and the risk of undefined behavior is significant in this context.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Additionally, ensure that both the source and destination pointers are not null before performing the copy operation. For example:\n\n```cpp\nif (outbox_ != nullptr && inbox_ != nullptr) {\n    memmove(outbox_, inbox_, bytes_);\n}\n```\n\nThis change ensures that the copy operation is safe even if the memory regions overlap, and it avoids dereferencing null pointers.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c101b4f5-a1bc-3fd9-b848-865b5539713d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure alternatives to these insecure C library functions. In the case of `strerror()`, a thread-safe alternative `strerror_r()` can be used.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with `strerror_r()` in the provided code snippet:\n\n```cpp\nchar buf[1024];\nstrerror_r(errno, buf, sizeof(buf));\nsignalAndThrowException(GLOO_ERROR_MSG(\"bind: \", buf))\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `errno.h`: for `errno`\n- `string.h`: for `strerror()`\n- `gloo`: for `GLOO_ERROR_MSG()`\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4a839d0b-8d38-3b17-9084-483267e3781c",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The source and destination pointers may refer to overlapping memory, as indicated by the data flow analysis. Additionally, there is a risk that either the source or destination pointer could be null, as there are no clear checks or guards in place to prevent this. The absence of explicit bounds checks or null pointer validation further increases the risk. These factors make this a high-confidence, actionable issue that could lead to unpredictable program behavior, crashes, or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, validate that both the source and destination pointers are not null before performing the copy operation.\n\n```cpp\nif (outbox_ != nullptr && ptrs_[0] != nullptr) {\n    // Use memmove instead of memcpy to safely handle possible overlap\n    memmove(outbox_, ptrs_[0], bytes_);\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "91199611-014a-3faf-bf9b-e0f43f77a6a7",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "c04123ce-49c4-30c1-8a74-1c270ccefdc7",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with functions like memcpy. There are no indications that the source or destination pointers are null, and the source is not a string literal or constant, which would otherwise reduce the risk. No explicit bounds or guards are present to mitigate the risk. Therefore, this is a high-confidence, actionable issue that should be addressed to prevent potential memory corruption or program instability.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely, whereas `memcpy` is not. Replace the original call with:\n\n```cpp\nmemmove(&attr.ai_addr, ifa->ifa_addr, attr.ai_addrlen);\n```\n\nThis change ensures that the memory copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "887de324-11b9-3d76-b5ae-8d3cbc594548",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with functions like memcpy. There are no guards or checks to prevent this, and neither the source nor destination is null at the call site, so the main concern is the potential for overlapping memory regions. This type of issue can lead to data corruption or crashes at runtime.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between regions that may overlap, use a function that is safe for overlapping memory, such as `memmove` instead of `memcpy`. Replace the original call with `memmove` to ensure correct behavior even if the source and destination overlap.\n\n```cpp\nmemmove(&attr.ai_addr, ifa->ifa_addr, attr.ai_addrlen);\n```\n\nThis change ensures that the memory copy will work correctly regardless of whether the source and destination regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "484d3575-2f87-3dcc-84e1-8c128bb3c7d8",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives such as `strerror_r()` in POSIX or `strerror_s()` in Windows. Always ensure that your code is thread-safe to prevent race conditions.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with `strerror_r()` or `strerror_s()` depending on your platform. Here is an example of how you can do it:\n\n```cpp\nchar buf[1024];\n#if (_POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600) && ! _GNU_SOURCE\n    strerror_r(errno, buf, sizeof(buf));\n#else\n    char *msg = strerror_r(errno, buf, sizeof(buf));\n#endif\nGLOO_ENFORCE_NE(rv, -1, msg)\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `errno.h`: for the `errno` variable\n- `string.h`: for the `strerror()` function\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4669bc03-2809-3a3b-96bc-a6a045fb9e3c",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with memcpy. Additionally, there is a risk that the source pointer may be null, as there is no prior check ensuring it is non-null. The destination is not likely to be null, but the overlap and null source risks make this a high-confidence issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(&attr.ai_addr, rp->ai_addr, rp->ai_addrlen);\n```\n\nAdditionally, ensure that `rp->ai_addr` is not null before performing the copy to avoid a null pointer dereference:\n\n```cpp\nif (rp->ai_addr != NULL) {\n    memmove(&attr.ai_addr, rp->ai_addr, rp->ai_addrlen);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "f6c4835d-7939-3d47-a95b-0bf2b378d2f2",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives such as `strerror_r()` in POSIX or `strerror_s()` in Windows. Always ensure that your code is thread-safe to prevent race conditions.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with `strerror_r()` or `strerror_s()` depending on your platform. Here is an example of how you can do it:\n\n```cpp\nchar buf[1024];\n#if (_POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600) && ! _GNU_SOURCE\n    strerror_r(errno, buf, sizeof(buf));\n#else\n    char *msg = strerror_r(errno, buf, sizeof(buf));\n#endif\nGLOO_ENFORCE_NE(rv, -1, msg)\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `errno.h`: for the `errno` variable\n- `string.h`: for the `strerror()` function\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "cbbb9097-eeac-381b-8aca-af1ab01330f7",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The dataflow analysis indicates that the destination and source may refer to overlapping memory, which is not allowed for the standard memory copy function used here. The verdict is supported by the classification and the explicit 'GENUINE' label. There are no guards or evidence that the source or destination are null, and the source and destination are not simple string literals or constant data, which would otherwise reduce the risk. The absence of a length derived from the destination's capacity and the lack of explicit null-termination further support the risk assessment. Developers should address this to prevent undefined behavior, which can lead to security vulnerabilities or program instability.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy function with one that is safe for overlapping regions. In C and C++, use `memmove` instead of `memcpy` for such cases. This ensures that the copy operation is performed correctly even if the regions overlap.\n\n```cpp\nmemmove(&attr.ai_addr, ifa->ifa_addr, attr.ai_addrlen);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "99b5bbb1-0972-39b7-a50a-ca1db3c91146",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that overlap is feasible based on data flow between the destination and source, which can cause undefined behavior with functions like memcpy. Additionally, the source may be null at this call site, which further increases the risk. There are no explicit guards or null-termination after the copy, and the destination's capacity is not clearly defined. These factors all contribute to the assessment that this is a real and actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely. Replace the original call with:\n\n```cpp\nmemmove(&attr->ai_addr, &address.address6, sizeof(address.address6));\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "be04ce1f-30aa-323d-a6c2-9c18527d80f7",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis detected that the source and destination may overlap based on data flow, which can cause unpredictable results with functions like memcpy. Additionally, there is a risk that the source pointer may be null, as there is no prior check ensuring it is valid. The destination is not likely to be null, but the overlap and null source risks make this a high-confidence, actionable issue. No explicit length or bounds checks are present, and the count argument is not derived from the destination's capacity, further increasing the risk.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n```cpp\nif (rp->ai_addr != nullptr) {\n    memmove(&attr.ai_addr, rp->ai_addr, rp->ai_addrlen);\n}\n```\n\nThis change replaces `memcpy` with `memmove` and adds a null check for the source pointer. This ensures safe copying even if the regions overlap and prevents undefined behavior if the source is null.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [NIST Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "70501dc7-6198-3fcd-b90e-abb0768c8744",
              "name": "Win32HardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol: Win32 - Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440077"
                ]
              }
            },
            {
              "id": "91e098d2-dc87-3d58-8be3-a7c4f2f5ba32",
              "name": "Win32HardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol: Win32 - Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440077"
                ]
              }
            },
            {
              "id": "7f452c7a-5ed1-3695-9b0b-0da17a39298d",
              "name": "Win32HardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol: Win32 - Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440077"
                ]
              }
            },
            {
              "id": "3f09ed87-c388-333a-b01d-4e208594f381",
              "name": "Win32HardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol: Win32 - Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440077"
                ]
              }
            },
            {
              "id": "5b1d914b-6111-3d7d-9784-247efed9b924",
              "name": "Win32HardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol: Win32 - Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440077",
                  "5b1d914b-6111-3d7d-9784-247efed9b924"
                ]
              }
            },
            {
              "id": "9de769fa-27fe-3eee-af7c-28fd05ce9052",
              "name": "Win32HardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol: Win32 - Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440077",
                  "9de769fa-27fe-3eee-af7c-28fd05ce9052"
                ]
              }
            },
            {
              "id": "55ef0220-6f55-35f7-8299-11461aff53cd",
              "name": "Win32HardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol: Win32 - Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440077"
                ]
              }
            },
            {
              "id": "1eeccbf6-ad54-366a-88b3-0eaa69aa73d1",
              "name": "OpensslDoNotHardcodeSsltlsVersionsWithinAnApplication",
              "shortDescription": {
                "text": "SSL/TLS version usage should be based on an OS or external configuration."
              },
              "fullDescription": {
                "text": "OpenSSL: Do not hardcode SSL/TLS versions within an application.: SSL/TLS version usage should be based on an OS or external configuration."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "SSL/TLS version usage should be based on an OS or external configuration.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "warning",
                "tags": [
                  "DS440010"
                ]
              }
            },
            {
              "id": "b8946a09-890f-3f81-b801-1d74ff8a3bfd",
              "name": "Win32HardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol: Win32 - Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440077",
                  "b8946a09-890f-3f81-b801-1d74ff8a3bfd"
                ]
              }
            },
            {
              "id": "b8946a09-890f-3f81-b801-1d74ff8a3bfd",
              "name": "OpensslDoNotHardcodeSsltlsVersionsWithinAnApplication",
              "shortDescription": {
                "text": "SSL/TLS version usage should be based on an OS or external configuration."
              },
              "fullDescription": {
                "text": "OpenSSL: Do not hardcode SSL/TLS versions within an application.: SSL/TLS version usage should be based on an OS or external configuration."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "SSL/TLS version usage should be based on an OS or external configuration.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "warning",
                "tags": [
                  "DS440010"
                ]
              }
            },
            {
              "id": "b8946a09-890f-3f81-b801-1d74ff8a3bfd",
              "name": "OpensslHardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "OpenSSL: Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "OpenSSL: Hard-coded SSL/TLS Protocol: OpenSSL: Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440001.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440001.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440001.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440011"
                ]
              }
            },
            {
              "id": "4e288d1a-50e0-3418-84ca-566448b856cb",
              "name": "Win32HardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol: Win32 - Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440077",
                  "4e288d1a-50e0-3418-84ca-566448b856cb"
                ]
              }
            },
            {
              "id": "c257b456-63b5-3a07-b942-5fbd7b94fc69",
              "name": "Win32HardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol: Win32 - Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440077",
                  "c257b456-63b5-3a07-b942-5fbd7b94fc69"
                ]
              }
            },
            {
              "id": "f48a3879-2d76-3904-93b7-b80317f0aa7c",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions. The analysis detected that the destination and source may refer to overlapping memory, which can cause undefined behavior when using functions like memcpy. Additionally, the source may be null at this call site, which further increases the risk. There are no explicit guards or checks to prevent these issues, and the function call is not protected by any bounds or overlap checks. The destination is not likely to be null, but the overlap and possible null source make this a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely. Replace the original call with:\n\n```cpp\nmemmove(&attr->ai_addr, &address.address4, sizeof(address.address4));\n```\n\nThis change ensures that the copy operation is safe even if the source and destination overlap.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "f60acd9d-4143-3a24-950e-f6b52ede8016",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers are derived from the same array or data structure, and dataflow analysis suggests that they may refer to overlapping memory. Additionally, the source pointer may be null, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues. The classification and verdict both indicate a high-confidence, actionable issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely, whereas `memcpy` is not. Replace the original call with:\n\n```cpp\nmemmove(ptrs_[i], ptrs_[0], bytes_);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap. Always validate that both pointers are non-null before performing the operation to avoid null pointer dereference.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3dbeca40-dd7d-3aa6-9fea-8092efc20793",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the `getenv` function is used, which is a potential security risk. The `getenv` function returns a pointer to a string that is stored in a static memory location. If this function is called multiple times, it can overwrite the previous value, leading to potential data races in multithreaded programs.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. In the case of `getenv`, consider using a thread-safe alternative if available, or protect the call with a mutex if the environment variable is accessed from multiple threads.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n#include <mutex>\n\nstd::mutex mtx;\n\n// ...\n\nmtx.lock();\nchar* universe_size = std::getenv(\"OMPI_UNIVERSE_SIZE\");\nresult.mpi = (universe_size != nullptr);\nmtx.unlock();\n```\n\nIn this code, the `getenv` function is protected by a mutex to prevent data races.\n\n## Library Dependencies\n\nThe code requires the following libraries:\n\n- cstdlib: for `std::getenv`\n- mutex: for `std::mutex`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "ca63e922-baab-3e7d-995e-2aba08bfabba",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it does not check for null termination. This means that if a string is not properly null-terminated, `strlen` will continue reading memory until it encounters a null byte, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string handling functions that include length parameters, such as `strnlen` or `strncpy`. These functions take an additional argument specifying the maximum length of the string to be processed, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nReplace the `strlen` function with the `strnlen` function, which includes a length parameter:\n\n```cpp\nresult.caFile = std::string(optarg, strnlen(optarg, MAX_LENGTH));\n```\n\nIn this code, `MAX_LENGTH` should be defined as the maximum expected length of `optarg`.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string`: for the `std::string` class.\n- `cstring`: for the `strlen` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "e3324a69-f358-32b9-a9e4-5d1091d390b7",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The dataflow analysis indicates that the destination and source may refer to overlapping memory, which is not allowed for the standard memory copy function used here. Additionally, the source pointer may be null at this call site, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the size of the memory region being copied is not derived from the capacity of the destination buffer. These factors all contribute to the high confidence in this being a real issue that could lead to memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the standard memory copy function with a function that safely handles overlapping regions. In C and C++, use `memmove` instead of `memcpy` for such cases. `memmove` is designed to correctly handle overlapping memory areas.\n\n**Remediation Example:**\n\n```cpp\nmemmove(static_cast<char*>(out->ptr) + myOutOffset, static_cast<char*>(in->ptr) + myInOffset, myChunkSize);\n```\n\nThis change ensures that the memory copy operation is safe even if the source and destination regions overlap. Additionally, consider adding checks to ensure that the source pointer is not null before performing the operation to avoid null pointer dereference.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "bd9fa479-fb9b-3b10-81fb-7dd0365b71ec",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it can lead to buffer overflow vulnerabilities if not used correctly. This is because `strlen` does not check for null termination and will continue reading memory until it encounters a null byte. If the string is not null-terminated, `strlen` could read beyond the allocated memory, leading to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string handling functions that include a length parameter. This allows you to specify the maximum number of characters to be read, preventing buffer overflows. \n\nIn C++, it is generally recommended to use the string class instead of C-style strings. The string class includes many functions that are safer and easier to use than the C-style string functions.\n\n## Source Code Fix Recommendation\n\nIn the provided code, the `strlen` function is used to determine the length of `optarg`. This can be replaced with the `std::string` constructor that takes a C-style string as an argument, which automatically determines the length of the string in a safe manner.\n\nHere is the fixed code:\n\n```cpp\nresult.caPath = std::string(optarg);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string`: This is a standard C++ library for handling strings.\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "2df6955a-5f11-3873-bf6a-8941b4726f3f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, and integer overflow attacks. In this case, the `atoi()` function is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `atoi()`, you can use `std::stoi()`, which throws an exception if the conversion fails or if the converted value is out of range.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\ntry {\n    result.messages = std::stoi(optarg);\n} catch (std::invalid_argument& e) {\n    // Handle exception: conversion failed\n} catch (std::out_of_range& e) {\n    // Handle exception: number out of range for int\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `cstdlib` (for `atoi()`)\n- `string` (for `std::stoi()`)\n\n## References\n\n- [CWE-681: Incorrect Conversion between Numeric Types](https://cwe.mitre.org/data/definitions/681.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "8c776783-f0ff-305b-82ab-552b39fa1f66",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `strlen(optarg)` is used to determine the length of `optarg`. If `optarg` is not null-terminated, this can lead to the aforementioned issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, ensure that all strings are null-terminated before passing them to `strlen`. Alternatively, consider using safer functions that take the size of the buffer as an argument, such as `strnlen`, which will not read past the specified length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(optarg)` with `strnlen(optarg, MAX_LEN)`, where `MAX_LEN` is the maximum expected length of `optarg`. This will prevent `strnlen` from reading past the end of `optarg`, even if it is not null-terminated.\n\n```cpp\nresult.sharedPath = std::string(optarg, strnlen(optarg, MAX_LEN));\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<string>`: for `std::string`\n- `<cstring>`: for `strlen` and `strnlen`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "c3e5f9ba-c15a-34f0-9201-7a9e2e53342d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Identified\" is a vulnerability that arises when a C++ program uses a function that is considered unsafe. This is because these functions do not perform bounds checking or other necessary validation, which can lead to buffer overflow attacks, memory corruption, and other security issues. In this case, the function `atoi()` is used, which is considered unsafe because it does not check for overflow or invalid input.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives that perform necessary validation. For instance, instead of `atoi()`, you can use `strtol()` or `sscanf()`, which provide error checking.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()`. Here is how you can do it:\n\n```cpp\nchar *end;\nlong int value = strtol(optarg, &end, 10);\nif (end == optarg || *end != '\\0' || errno == ERANGE) {\n    // handle error\n} else {\n    result.base = value;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `stdlib.h`: for `strtol()`\n- `errno.h`: for `errno`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "f8a85ba7-f1fd-3a88-af26-840e6bd705cb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it does not include the null character at the end of the string. This can lead to buffer overflow vulnerabilities if the length of the string is not properly checked before it is used.\n\nIn the provided code snippet, `strlen(optarg)` is used to determine the length of the string `optarg`. If `optarg` is not null-terminated, `strlen(optarg)` could return a value larger than the actual size of the string, leading to a buffer overflow when the string is copied into `result.cert`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that your strings are null-terminated before using functions like `strlen`. Additionally, consider using safer alternatives to `strlen` that include bounds checking, such as `strnlen`.\n\n## Source Code Fix Recommendation\n\nA safer version of the code snippet might look like this:\n\n```cpp\nsize_t length = strnlen(optarg, MAX_LENGTH);\nresult.cert = std::string(optarg, length);\n```\n\nIn this version, `strnlen` is used instead of `strlen`. `strnlen` will only count up to `MAX_LENGTH` characters, preventing a buffer overflow if `optarg` is not null-terminated.\n\n## Library Dependencies\n\nThe code snippet requires the following library dependencies:\n\n- `<string>` for `std::string`\n- `<cstring>` for `strlen` and `strnlen`\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "3cd67c0a-f7e1-3559-aa4c-3142d58d532f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it does not check for null termination. This means that if a string is not properly null-terminated, `strlen` will continue reading memory until it encounters a null byte, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nThis vulnerability is particularly dangerous because it can lead to serious security issues, such as arbitrary code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string handling functions that do not rely on null termination to determine the length of the string. In C++, this can be achieved by using the `std::string` class, which automatically keeps track of the string length and ensures null termination.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the vulnerability can be fixed by simply removing the `strlen` function. The `std::string` constructor can take a C-string as an argument and automatically determine its length:\n\n```cpp\nresult.pkey = std::string(optarg);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string`: This is a standard C++ library for handling strings.\n- `getopt`: This is a library used for parsing command line arguments.\n\n## References\n\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are subject to change and may not be accessible at all times. Always ensure to use the latest and most reliable resources when dealing with security vulnerabilities."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "f8a65901-b084-3031-b427-923f685177bb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the function `atoi()` is used, which can lead to integer overflow or underflow if the input string represents a number outside the range of representable integer values.\n\n## Mitigation Advice\n\nAvoid using unsafe C functions like `atoi()`. Instead, use safer alternatives that perform error checking. For example, the `strtol()` function can be used to convert a string to a long integer, and it provides a way to check for errors.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()`. Here's how you can do it:\n\n```cpp\nchar *end;\nlong int port = strtol(optarg, &end, 10);\nif (end == optarg || *end != '\\0' || errno == ERANGE) {\n    // handle error\n} else {\n    result.ibverbsPort = port;\n}\n```\n\nIn this code, `strtol()` is used to convert the string to a long integer. If the conversion is successful, the `end` pointer will point to the end of the string. If the conversion fails, `end` will point to the part of the string that couldn't be converted. The `errno` variable is checked to see if the conversion resulted in overflow or underflow.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `stdlib.h` for `strtol()`\n- `errno.h` for `errno`\n\n## References\n\n- [OWASP Prohibited C Functions](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html#prohibited-c-library-functions)\n- [CWE-681: Incorrect Conversion between Numeric Types](https://cwe.mitre.org/data/definitions/681.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "2d364472-da6b-34b1-9c15-ee6bbe4b2598",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or integer overflows. In this case, the function `atoi()` is used, which can lead to integer overflow or underflow if the input is not properly validated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or to perform proper input validation before using them. In the case of `atoi()`, it does not perform any error checking, so it can lead to undefined behavior if the input string cannot be converted to an integer. \n\n## Source Code Fix Recommendation\n\nA safer alternative to `atoi()` is `strtol()`, which performs error checking. Here is how you can use it:\n\n```cpp\nchar *end;\nlong int value = strtol(optarg, &end, 10);\n\nif (end == optarg || *end != '\\0' || errno == ERANGE) {\n    // handle error\n} else {\n    result.ibverbsIndex = value;\n}\n```\n\nIn this code, `strtol()` tries to convert `optarg` to a `long int`. If `optarg` does not contain any digits, `end` will be equal to `optarg`. If `optarg` contains any non-digit characters after the number, they will be stored in `*end`. If the number is too large or too small to fit in a `long int`, `errno` will be set to `ERANGE`.\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `stdlib.h` for `strtol()`\n- `errno.h` for `errno`\n\n## References\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "81dbaff4-95d0-3e61-9921-7deb3c40a79c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the function `atoi()` is used, which can lead to integer overflow or underflow if the input string represents a number outside the range of representable integer values.\n\n## Mitigation Advice\n\nAvoid using unsafe C functions like `atoi()`. Instead, use safer alternatives that perform bounds checking or error handling. For example, you can use `strtol()` or `sscanf()` for string to integer conversion, which provide error checking mechanisms.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()`. Here is an example of how to do it:\n\n```cpp\nchar *end;\nlong int value = strtol(optarg, &end, 10);\nif (end == optarg || *end != '\\0' || errno == ERANGE) {\n    // handle error\n} else {\n    result.threads = value;\n}\n```\n\nIn this code, `strtol()` is used to convert the string to a long integer. If the conversion is unsuccessful, `end` will point to the first invalid character in `optarg`, or `errno` will be set to `ERANGE` if the number is out of range.\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `stdlib.h` for `strtol()`\n- `errno.h` for `errno`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "e2c7d5ed-7db2-3fda-8f80-d0a6339e9da8",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, integer overflow, etc. In this case, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using C library functions that do not perform bounds checking or input validation. Instead, use safer alternatives provided by the C++ Standard Library. For `atoi()`, a safer alternative is `std::stoi()`, which throws an exception if the input string cannot be converted to an integer or if the converted value is out of the range of representable values by an `int`.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\ntry {\n    result.destinations = std::stoi(optarg);\n} catch (std::invalid_argument& e) {\n    // Handle the case where 'optarg' cannot be converted to an integer\n} catch (std::out_of_range& e) {\n    // Handle the case where the converted value is out of the range of representable values by an 'int'\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `cstdlib` (for `atoi()`)\n- `string` (for `std::stoi()`)\n\n## OWASP Resources\n\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-681: Incorrect Conversion between Numeric Types](https://cwe.mitre.org/data/definitions/681.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "efacfc8b-173e-303f-adb3-d67aa6346442",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, integer overflow, etc. In this case, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For `atoi()`, a safer alternative is `std::stoi()`, which throws an exception if the conversion fails or if the converted value is out of range.\n\n## Source Code Fix Recommendation\n\nReplace `atoi(optarg)` with `std::stoi(optarg)`. Here is the fixed code:\n\n```cpp\ntry {\n    result.iterationCount = std::stoi(optarg);\n} catch (std::invalid_argument& e) {\n    // Handle exception: conversion failed\n} catch (std::out_of_range& e) {\n    // Handle exception: converted value is out of range\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>` for `atoi()`\n- `<string>` for `std::stoi()`\n\n## References\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "a7692905-3771-3416-966a-7b1d4e8a0a9e",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, integer overflow, etc. In this case, the function `atoi()` is used, which is a standard C library function that converts a string into an integer. The problem with `atoi()` is that it does not handle errors well. If the input string cannot be converted into an integer, it returns zero, which can lead to unexpected behavior.\n\n## Mitigation Advice\n\nAvoid using C library functions that do not perform bounds checking or error checking. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `atoi()`, you can use `std::stoi()`, which throws an exception if the conversion fails.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\n#include <string>\n\ntry {\n    result.inputs = std::stoi(optarg);\n} catch (std::invalid_argument& e) {\n    // handle error\n} catch (std::out_of_range& e) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `cstdlib` for `atoi()`\n- `string` for `std::stoi()`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "24ab890a-c55a-33ed-952a-7adff6d4a167",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the `atoi()` function is used, which is a prohibited C function. This function converts a string to an integer and it does not handle errors properly. If the input string cannot be converted into an integer, it returns zero, which can lead to unexpected behavior.\n\n## Mitigation Advice\n\nAvoid using unsafe C functions. Instead, use safer alternatives that are available. For instance, instead of `atoi()`, you can use `strtol()` or `sscanf()`, which provide error checking. Always validate and sanitize user input to prevent injection attacks. \n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()`. Here is the fixed code:\n\n```cpp\n#include <cstdlib>\n#include <cctype>\n\nchar *end;\nlong val = strtol(optarg, &end, 10);\nif (end == optarg || *end != '\\0' || errno == ERANGE) {\n    // handle conversion error\n} else if (val == 1 || tolower(optarg[0]) == 't' || tolower(optarg[0]) == 'y') {\n    // proceed with the rest of the code\n}\n```\n\n## Library Dependencies\n\nThe code requires the following libraries:\n\n- cstdlib: for `strtol()`\n- cctype: for `tolower()`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "5e38f064-f633-3c39-811e-5584912118a7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the `atoi()` function is used, which is a prohibited C function. This function converts a string to an integer and it does not handle errors properly. If the input string cannot be converted into an integer, it returns zero, which can lead to unexpected behavior.\n\n## Mitigation Advice\n\nAvoid using unsafe C functions. Instead, use safer alternatives that are available. For instance, instead of `atoi()`, you can use `strtol()` or `sscanf()`, which provide error checking. Always validate and sanitize user input to prevent injection attacks. \n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()`. Here is the fixed code:\n\n```cpp\n#include <cstdlib>\n#include <cctype>\n\nchar *end;\nlong val = strtol(optarg, &end, 10);\nif (end == optarg || *end != '\\0' || errno == ERANGE) {\n    // handle conversion error\n} else if (val == 1 || tolower(optarg[0]) == 't' || tolower(optarg[0]) == 'y') {\n    // proceed with the rest of the code\n}\n```\n\n## Library Dependencies\n\nThe code requires the following libraries:\n\n- cstdlib: for `strtol()`\n- cctype: for `tolower()`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "0d16502c-dac1-343a-8e9a-9ea348d9583b",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or integer overflow attacks. In this case, the function `atoi()` is used, which can lead to integer overflow or underflow if the input is not properly validated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For `atoi()`, a safer alternative would be `strtol()` or `sscanf()`. These functions provide error checking which can prevent integer overflow or underflow attacks.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()` or `sscanf()`. Here is an example of how to use `strtol()`:\n\n```cpp\nchar *end;\nlong int value = strtol(optarg, &end, 10);\nif (end == optarg || *end != '\\0' || errno == ERANGE) {\n    // handle error\n} else {\n    result.elements = value;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `stdlib.h` for `strtol()`\n- `errno.h` for `errno`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "a54dd078-0b74-3e95-a2ea-156a49004713",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the function `atoi()` is used, which is a standard C library function that converts a string to an integer. The problem with `atoi()` is that it does not perform any error checking. If the input string cannot be converted into an integer, it returns zero, which can lead to unexpected behavior.\n\n## Mitigation Advice\n\nAvoid using C library functions that do not perform error checking or can lead to buffer overflows. Instead, use safer alternatives provided by the C++ Standard Library. For example, instead of `atoi()`, you can use `std::stoi()`, which throws an exception if the conversion fails.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\ntry {\n    result.warmupIterationCount = std::stoi(optarg);\n} catch (std::invalid_argument& e) {\n    // Handle exception: the conversion could not be performed\n} catch (std::out_of_range& e) {\n    // Handle exception: the converted value would fall out of the range of the result type\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `cstdlib` (for `atoi()`)\n- `string` (for `std::stoi()`)\n\n## References\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "9d8be6d3-e2ac-335a-b9c4-533c4b1541d0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the function `atoi()` is used, which can lead to integer overflow or underflow if the input string represents a number outside the range of representable integer values.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions that include proper error handling and boundary checks. For `atoi()`, a safer alternative could be `strtol()` or `sscanf()`, which provide error checking.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()` or `sscanf()`. Here is an example of how to use `strtol()`:\n\n```cpp\nchar *end;\nlong int port = strtol(optarg, &end, 10);\nif (end == optarg || *end != '\\0' || errno == ERANGE) {\n    // handle error\n} else {\n    result.redisPort = port;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `stdlib.h` for `strtol()`\n- `errno.h` for `errno`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "7810f9db-7e92-3ebd-be8d-4010dd6c6b0d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other undefined behaviors.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character or by manually adding a null character at the end of your string. Additionally, consider using safer alternatives to `strlen`, such as `strnlen`, which takes an additional parameter specifying the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the vulnerability can be fixed by replacing `strlen` with `strnlen` and specifying a maximum length for the string. Here's how you can do it:\n\n```cpp\nsize_t max_length = 100; // replace with your maximum length\nresult.prefix = std::string(optarg, strnlen(optarg, max_length));\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string`: for the `std::string` class.\n- `cstring`: for the `strlen` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "fdbe6aa7-0ddf-3415-8463-4a69dcc9e504",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it can lead to buffer overflow vulnerabilities if not used correctly. This is because `strlen` does not check for the null character at the end of the string, which can lead to reading beyond the allocated memory if the string is not properly null-terminated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string handling functions that include bounds checking, such as `strnlen` or `strncpy`. These functions take an additional parameter that specifies the maximum number of characters to be copied or read, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nresult.transport = std::string(optarg, strnlen(optarg, MAX_LEN));\n```\n\nIn this code, `MAX_LEN` should be defined as the maximum expected length of `optarg`. This ensures that `strnlen` will not read beyond this length, even if `optarg` is not properly null-terminated.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string`: This is a standard C++ library that provides support for strings.\n- `cstring`: This is a standard C library that provides support for string handling functions like `strlen`.\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "c7d97622-b1ff-392c-86e3-92511e584f26",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the function `atoi()` is used, which can lead to integer overflow or underflow if the input string represents a number outside the range of representable integer values.\n\n## Mitigation Advice\n\nAvoid using unsafe C functions like `atoi()`. Instead, use safer alternatives that perform error checking. For example, you can use `strtol()` or `sscanf()` for string to integer conversion, which provide error checking mechanisms.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()`. Here's how you can do it:\n\n```cpp\nchar *end;\nlong int value = strtol(optarg, &end, 10);\nif (end == optarg || *end != '\\0' || errno == ERANGE) {\n    // handle error\n} else {\n    result.contextSize = value;\n}\n```\n\nIn this code, `strtol()` is used to convert the string to a long integer. If the conversion is successful, the converted value is assigned to `result.contextSize`. If the conversion fails, an error is handled.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `stdlib.h`: for `strtol()`\n- `errno.h`: for `errno`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "a9811300-2dc0-3a94-a43f-ba712fe27b8b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it can lead to buffer overflow vulnerabilities if not used correctly. This is because `strlen` does not check for null termination and will continue reading memory until it encounters a null byte. If the string is not null-terminated, `strlen` could read beyond the allocated memory, leading to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string handling functions that include length checks. In C++, this could be the `std::string` constructor that takes only a `char*` parameter. This constructor automatically calculates the length of the string in a safe manner.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nresult.redisHost = std::string(optarg);\n```\n\nIn this version, the `std::string` constructor automatically calculates the length of the string, mitigating the risk of a buffer overflow.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string`: This is a standard C++ library for handling strings.\n- `unistd.h`: This is a standard C library that provides access to the POSIX operating system API.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "2a9155fa-0910-3e85-9ee8-c10809a0f46e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen` will continue reading memory beyond the intended boundary, leading to a buffer overflow. This can cause crashes, incorrect behavior, or even allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Be careful when manipulating strings, especially when using functions like `strcpy` or `strcat` that can overwrite the null terminator. Also, consider using safer alternatives to `strlen` that take a maximum length parameter, such as `strnlen`.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```c++\nlen = strlen(str);\n```\n\nYou could use:\n\n```c++\nlen = strnlen(str, MAX_LEN);\n```\n\nWhere `MAX_LEN` is the maximum expected length of the string. This will prevent `strnlen` from reading beyond this limit, even if `str` is not null-terminated.\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library, so no additional libraries are needed. The `strnlen` function is part of the POSIX library, so it may not be available on non-POSIX systems.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "cba32b7f-4d97-34c0-8169-ceab94ddba9a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis found that the source and destination may overlap based on data flow, which can cause unpredictable results with memcpy. Additionally, both the source and destination pointers may be null at this call site, increasing the risk of runtime errors. There are no explicit guards or checks to prevent these issues, and the size argument is not derived from the destination's capacity. This combination of factors makes the issue highly likely to be a real vulnerability that could lead to memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that neither the source nor the destination pointers are null before performing the copy to avoid null pointer dereference.\n\n```cpp\nif (bytes.data() != nullptr && &impl_ != nullptr) {\n    memmove(bytes.data(), &impl_, sizeof(impl_));\n}\n```\n\nIf you are certain that the regions never overlap, document this assumption clearly in the code and add runtime assertions if possible. Otherwise, prefer `memmove` for safety.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ab8929f6-6b17-3a0c-bf43-f8532908fa4c",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, integer overflow, etc. In this case, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using C library functions that do not perform bounds checking or input validation. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `atoi()`, use `std::stoi()` which throws an exception if the input string represents a number outside the range of `int`.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\n#include <string>\n\ntry {\n    result.contextRank = std::stoi(optarg);\n} catch (std::out_of_range& e) {\n    // Handle the exception\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<string>`: This is a standard C++ library for string manipulation.\n\n## References\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "502524ae-2967-3866-a3de-e61cff565aea",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives like `strerror_r()` in POSIX or `strerror_s()` in Windows. Also, consider using higher-level abstractions provided by the C++ Standard Library, which are usually safer and less error-prone.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with its thread-safe counterpart `strerror_r()`:\n\n```cpp\nchar buf[1024];\nGLOO_ENFORCE_NE(rv, -1, \"getpeername: \", strerror_r(errno, buf, sizeof(buf)))\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `errno.h`: for `errno`\n- `string.h`: for `strerror()`\n- `gloo/Enforce.h`: for `GLOO_ENFORCE_NE()`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "84c31292-7681-3f25-b444-13ca03b04444",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memcpy operation. The dataflow analysis indicates that the destination and source may refer to overlapping memory, which is not allowed for memcpy and can result in unpredictable program behavior. Additionally, there is a risk that the source pointer may be null at this call site, as there is no prior check ensuring it is non-null. The destination is not likely to be null, but the overlap and null source risks make this a high-confidence issue. No explicit bounds or guards are present to mitigate these risks.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n```cpp\nif (bytes.data() != nullptr) {\n    memmove(&impl_, bytes.data(), sizeof(impl_));\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [NIST Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "925eacb8-64c8-347c-8b89-09c6c3d4ccf8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use thread-safe alternatives to these insecure C library functions. In the case of `strerror()`, the thread-safe alternative is `strerror_r()`.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with `strerror_r()` in the provided code snippet:\n\n```cpp\nchar buf[1024];\nGLOO_ENFORCE_NE(rv, -1, \"getsockname: \", strerror_r(errno, buf, sizeof(buf)))\n```\n\n## Library Dependencies\n\nThe provided code snippet requires the following libraries:\n\n- `errno.h`: for the `errno` variable\n- `string.h`: for the `strerror()` function\n- `gloo/Enforce.h`: for the `GLOO_ENFORCE_NE()` macro\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "147e01b3-93eb-3b70-a88c-e17130c827c2",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Production Debug Code Presence\" vulnerability refers to the situation where debug code is accidentally left in the production environment. This can lead to a variety of security issues, including unauthorized access, information disclosure, and even remote code execution. In C++ programming, this vulnerability can occur if the debug code is not properly managed and removed before the application is deployed in a production environment.\n\nIn the provided code snippet, the `gloo::transport::tcp::CreateDevice(\"localhost\")` function is used, which might be part of a debug code. If this code is left in the production environment, it could potentially expose sensitive information or allow unauthorized access.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n- Always remove debug code or any code that is not necessary for the production environment before deploying the application.\n- Use preprocessor directives to ensure that debug code is not compiled into the final production build.\n- Regularly review and audit the code to ensure that no debug code is left in the production environment.\n- Use automated tools to detect and remove debug code.\n\n## Source Code Fix Recommendation\n\nThe fix would involve removing the debug code or wrapping it with preprocessor directives. Here is an example:\n\n```cpp\n#ifndef NDEBUG\ndev = gloo::transport::tcp::CreateDevice(\"localhost\")\n#endif\n```\n\nIn this example, the debug code will only be compiled if the `NDEBUG` macro is not defined. This macro is usually not defined in the production build, so the debug code will be excluded.\n\n## Library Dependencies\n\nThe provided code snippet seems to be using the Gloo library for collective communications over TCP. Therefore, the Gloo library would be a required dependency.\n\n## References\n\n- [CWE-489: Leftover Debug Code](https://cwe.mitre.org/data/definitions/489.html)\n\nPlease note that the links provided are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS162092"
                ]
              }
            },
            {
              "id": "796c26a7-c265-3a6b-aff6-b75f8ef423b6",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Production Debug Code Presence\" vulnerability refers to the situation where debug code is accidentally left in the production environment. This can lead to a variety of security issues, including unauthorized access, information disclosure, and even remote code execution. In C++ programming, this vulnerability can occur if the debug code is not properly managed and removed before the application is deployed in a production environment.\n\nIn the provided code snippet, the `gloo::transport::tcp::CreateDevice(\"localhost\")` function is used, which might be part of a debug code. If this code is left in the production environment, it could potentially expose sensitive information or allow unauthorized access.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n- Always remove debug code or any code that is not necessary for the production environment before deploying the application.\n- Use preprocessor directives to ensure that debug code is not compiled into the final production build.\n- Regularly review and audit the code to ensure that no debug code is left in the production environment.\n- Use automated tools to detect and remove debug code.\n\n## Source Code Fix Recommendation\n\nThe fix would involve removing the debug code or wrapping it with preprocessor directives. Here is an example:\n\n```cpp\n#ifndef NDEBUG\ndev = gloo::transport::tcp::CreateDevice(\"localhost\")\n#endif\n```\n\nIn this example, the debug code will only be compiled if the `NDEBUG` macro is not defined. This macro is usually not defined in the production build, so the debug code will be excluded.\n\n## Library Dependencies\n\nThe provided code snippet seems to be using the Gloo library for collective communications over TCP. Therefore, the Gloo library would be a required dependency.\n\n## References\n\n- [CWE-489: Leftover Debug Code](https://cwe.mitre.org/data/definitions/489.html)\n\nPlease note that the links provided are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS162092"
                ]
              }
            },
            {
              "id": "2964b590-e367-3b83-bf0b-0ef6a7ba8892",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence of a guard to ensure the source is non-null, which further increases the risk. The destination is not a pointer-based member, reducing the risk of it being null, but the source may still be null. The classification and verdict both indicate a high-confidence issue that should be addressed to prevent undefined behavior and potential security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add a check to ensure the source pointer is not null before performing the copy operation.\n\n```cpp\nif (addr != nullptr) {\n    memmove(&impl_.ss, addr, addrlen);\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3e3dc112-dcaf-3b74-a4cf-b5adab26662e",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `strerror` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror`. Instead, use thread-safe alternatives such as `strerror_r` in POSIX or `strerror_s` in Windows. \n\n## Source Code Fix Recommendation\n\nReplace the `strerror` function with `strerror_r`:\n\n```cpp\nchar buf[1024];\nGLOO_ENFORCE_NE(rv, -1, \"epoll_ctl: \", strerror_r(errno, buf, sizeof(buf)))\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `errno.h`: for `errno`\n- `string.h`: for `strerror`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "beae45ff-f160-3097-b4f3-484ade617825",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `strerror` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror`. Instead, use thread-safe alternatives such as `strerror_r` in POSIX or `strerror_s` in Windows. \n\n## Source Code Fix Recommendation\n\nReplace the `strerror` function with `strerror_r`:\n\n```cpp\nchar buf[1024];\nGLOO_ENFORCE_NE(rv, -1, \"epoll_ctl: \", strerror_r(errno, buf, sizeof(buf)))\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `errno.h`: for `errno`\n- `string.h`: for `strerror`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "dec4341d-62fc-34c2-ad1b-b8046dda5d15",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ refers to the use of certain C library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other types of security issues. These functions are often prohibited in secure coding standards due to their inherent risks.\n\nIn the provided code snippet, the function `strerror(errno)` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment. This is because `strerror` returns a pointer to a static buffer that is overwritten by each call, so concurrent calls from different threads can overwrite the data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use thread-safe alternatives to unsafe C functions. In the case of `strerror`, a safer alternative is `strerror_r` in POSIX systems or `strerror_s` in Windows.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror(errno)` function with `strerror_r(errno, buf, sizeof buf)` or `strerror_s(buf, sizeof buf, errno)` depending on your platform. Ensure to define a buffer `buf` of appropriate size.\n\n```cpp\nchar buf[1024];\nGLOO_ENFORCE_NE(fd_, -1, \"epoll_create: \", strerror_r(errno, buf, sizeof buf))\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<errno.h>`: for `errno`\n- `<string.h>`: for `strerror_r` or `strerror_s`\n- `gloo/common/logging.h`: for `GLOO_ENFORCE_NE`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "ead99fcb-877b-30a8-acdd-70a6b681c402",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers are derived from potentially related structures, and dataflow analysis suggests that they may overlap. Additionally, the source pointer may be null, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the function used (`memcpy`) does not handle overlapping memory regions safely. This combination of factors makes the issue a high-confidence, actionable problem that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation 0\nTo prevent undefined behavior when the source and destination memory regions may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to safely handle overlapping regions, whereas `memcpy` is not. Replace the original call with `memmove`:\n\n```cpp\nmemmove(static_cast<uint8_t*>(out->ptr) + byteOffsets[context->rank], static_cast<uint8_t*>(in->ptr), in->size);\n```\n\nThis change ensures that the memory copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n## In Context Remediation 1\nBefore performing the memory copy, add explicit checks to ensure that the source pointer is not null and that the size is valid. This helps prevent undefined behavior due to null pointer dereference:\n\n```cpp\nif (in->ptr != nullptr && in->size > 0) {\n    memmove(static_cast<uint8_t*>(out->ptr) + byteOffsets[context->rank], static_cast<uint8_t*>(in->ptr), in->size);\n}\n```\n\nThis approach adds a guard to prevent copying from a null source pointer and ensures that the operation only occurs when there is data to copy.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "19572b35-2996-3c12-ad9b-5dfbd5277446",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Production Debug Code Presence\" vulnerability refers to the situation where debug code is accidentally left in the production environment. This can lead to a variety of security issues, including unauthorized access, information disclosure, and even remote code execution. In C++ programming, this vulnerability can occur if the debug code is not properly managed and removed before the application is deployed in a production environment.\n\nIn the provided code snippet, the `gloo::transport::tcp::CreateDevice(\"localhost\")` function is used, which might be part of a debug code. If this code is left in the production environment, it could potentially expose sensitive information or allow unauthorized access.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n- Always remove debug code or any code that is not necessary for the production environment before deploying the application.\n- Use preprocessor directives to ensure that debug code is not compiled into the final production build.\n- Regularly review and audit the code to ensure that no debug code is left in the production environment.\n- Use automated tools to detect and remove debug code.\n\n## Source Code Fix Recommendation\n\nThe fix would involve removing the debug code or wrapping it with preprocessor directives. Here is an example:\n\n```cpp\n#ifndef NDEBUG\ndev = gloo::transport::tcp::CreateDevice(\"localhost\")\n#endif\n```\n\nIn this example, the debug code will only be compiled if the `NDEBUG` macro is not defined. This macro is usually not defined in the production build, so the debug code will be excluded.\n\n## Library Dependencies\n\nThe provided code snippet seems to be using the Gloo library for collective communications over TCP. Therefore, the Gloo library would be a required dependency.\n\n## References\n\n- [CWE-489: Leftover Debug Code](https://cwe.mitre.org/data/definitions/489.html)\n\nPlease note that the links provided are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS162092"
                ]
              }
            },
            {
              "id": "a3d938ca-7024-3b3a-adc2-2803f47a59da",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform bounds checking or handle errors more gracefully. In this case, consider using `strtol()` or `sscanf()` instead of `atoi()`. Always validate and sanitize input data.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n#include <climits>\n#include <cerrno>\n\nconst char* rankStr = getenv(\"RANK\");\nif(rankStr == NULL) {\n    // handle error\n}\n\nchar* end;\nlong rank = strtol(rankStr, &end, 10);\nif (end == rankStr || *end != '\\0' || errno == ERANGE || rank > INT_MAX || rank < INT_MIN) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\n- cstdlib\n- climits\n- cerrno\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)"
              },
              "properties": {
                "tags": [
                  "DS154189",
                  "a3d938ca-7024-3b3a-adc2-2803f47a59da"
                ]
              }
            },
            {
              "id": "7c45b348-6d3d-3d8f-8315-5d9398c422be",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using unsafe C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `atoi()`, you can use `std::stoi()` which throws an exception if the conversion fails or if the converted value is out of range.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\n#include <cstdlib>\n#include <string>\n\n// ...\n\ntry {\n    size = std::stoi(getenv(\"SIZE\"));\n} catch (const std::invalid_argument& ia) {\n    // Handle the exception\n} catch (const std::out_of_range& oor) {\n    // Handle the exception\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstdlib` for `getenv()`\n- `string` for `std::stoi()`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n\nPlease note that the links are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189",
                  "7c45b348-6d3d-3d8f-8315-5d9398c422be"
                ]
              }
            },
            {
              "id": "698884a4-369f-39e7-a091-19a1f6de3cbd",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, and other security issues. In the provided code snippet, the function `getenv()` is used, which can lead to security vulnerabilities. This function returns a pointer to the value in the environment, or NULL if there is no match. The returned string should not be modified by the program, but it can be overwritten by a subsequent call to `getenv()`, `setenv()`, or `unsetenv()`.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. In this case, consider using a safer method to retrieve environment variables.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // for std::getenv\n\nconst char* prefix = std::getenv(\"PREFIX\");\nif (!prefix) {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\n- cstdlib\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "76ed438d-d886-34d4-b760-ae984955c673",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform bounds checking or handle errors more gracefully. In this case, consider using `strtol()` or `sscanf()` instead of `atoi()`. Always validate and sanitize input data.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n#include <climits>\n#include <cerrno>\n\nconst char* rankStr = getenv(\"RANK\");\nif(rankStr == NULL) {\n    // handle error\n}\n\nchar* end;\nlong rank = strtol(rankStr, &end, 10);\nif (end == rankStr || *end != '\\0' || errno == ERANGE || rank > INT_MAX || rank < INT_MIN) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\n- cstdlib\n- climits\n- cerrno\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)"
              },
              "properties": {
                "tags": [
                  "DS154189",
                  "76ed438d-d886-34d4-b760-ae984955c673"
                ]
              }
            },
            {
              "id": "2b42892c-ab0b-35da-bfb3-97745b617eff",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using unsafe C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `atoi()`, you can use `std::stoi()` which throws an exception if the conversion fails or if the converted value is out of range.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\n#include <cstdlib>\n#include <string>\n\n// ...\n\ntry {\n    size = std::stoi(getenv(\"SIZE\"));\n} catch (const std::invalid_argument& ia) {\n    // Handle the exception\n} catch (const std::out_of_range& oor) {\n    // Handle the exception\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstdlib` for `getenv()`\n- `string` for `std::stoi()`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n\nPlease note that the links are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189",
                  "2b42892c-ab0b-35da-bfb3-97745b617eff"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "70fb2565-7708-3f75-90cc-bd0da2a734fc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/allreduce_ring_chunked.h"
                },
                "region": {
                  "startLine": 184,
                  "startColumn": 8,
                  "endLine": 184,
                  "endColumn": 77,
                  "charOffset": 6071,
                  "charLength": 69,
                  "snippet": {
                    "text": "memcpy(&ptrs_[0][offset], inbox_[chunkOffset & 1], length * sizeof(T)",
                    "rendered": {
                      "text": "memcpy(&ptrs_[0][offset], inbox_[chunkOffset & 1], length * sizeof(T)",
                      "markdown": "`memcpy(&ptrs_[0][offset], inbox_[chunkOffset & 1], length * sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/allreduce_ring_chunked.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6071,
                        "charLength": 69
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&ptrs_[0][offset], <size of &ptrs_[0][offset]>,  inbox_[chunkOffset & 1],  length * sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "03e0fab1-b339-3b6d-8a5a-0eb97d3704e8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/allreduce_ring_chunked.h"
                },
                "region": {
                  "startLine": 96,
                  "startColumn": 8,
                  "endLine": 96,
                  "endColumn": 42,
                  "charOffset": 2696,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                    "rendered": {
                      "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                      "markdown": "`memcpy(ptrs_[i], ptrs_[0], bytes_)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/allreduce_ring_chunked.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2696,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptrs_[i], <size of ptrs_[i]>,  ptrs_[0],  bytes_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ec005ff6-7e92-366d-b865-51282adf062a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/allreduce_ring_chunked.h"
                },
                "region": {
                  "startLine": 210,
                  "startColumn": 6,
                  "endLine": 210,
                  "endColumn": 40,
                  "charOffset": 6946,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                    "rendered": {
                      "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                      "markdown": "`memcpy(ptrs_[i], ptrs_[0], bytes_)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/allreduce_ring_chunked.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6946,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptrs_[i], <size of ptrs_[i]>,  ptrs_[0],  bytes_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6c86517b-7edb-3fc1-b7cd-cd26cf5b2d5d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/uv/libuv.h"
                },
                "region": {
                  "startLine": 638,
                  "startColumn": 9,
                  "endLine": 638,
                  "endColumn": 41,
                  "charOffset": 15723,
                  "charLength": 32,
                  "snippet": {
                    "text": "memcpy(data.get(), &t, sizeof(T)",
                    "rendered": {
                      "text": "memcpy(data.get(), &t, sizeof(T)",
                      "markdown": "`memcpy(data.get(), &t, sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/uv/libuv.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15723,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "memcpy_s(data.get(), <size of data.get()>,  &t,  sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "b42dc0bb-aaf4-31da-96ac-52e576a75c3c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Win32 - Hard-coded SSL/TLS Protocol"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/tls/openssl.h"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 5,
                  "endLine": 32,
                  "endColumn": 31,
                  "charOffset": 773,
                  "charLength": 26,
                  "snippet": {
                    "text": "SSL_CTX_set_security_level",
                    "rendered": {
                      "text": "SSL_CTX_set_security_level",
                      "markdown": "`SSL_CTX_set_security_level`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.Protocol.TLS.Hard-Coded"
            ]
          }
        },
        {
          "ruleId": "7bdbca30-24e7-327c-99e4-879c4effe401",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Win32 - Hard-coded SSL/TLS Protocol"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/tls/openssl.h"
                },
                "region": {
                  "startLine": 22,
                  "startColumn": 9,
                  "endLine": 22,
                  "endColumn": 20,
                  "charOffset": 501,
                  "charLength": 11,
                  "snippet": {
                    "text": "SSL_CTX_new",
                    "rendered": {
                      "text": "SSL_CTX_new",
                      "markdown": "`SSL_CTX_new`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.Protocol.TLS.Hard-Coded"
            ]
          }
        },
        {
          "ruleId": "e7aa8d31-6ac7-3e92-9c9b-7a898e06ce46",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Win32 - Hard-coded SSL/TLS Protocol"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/tls/openssl.h"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 18,
                  "endLine": 20,
                  "endColumn": 28,
                  "charOffset": 473,
                  "charLength": 10,
                  "snippet": {
                    "text": "TLS_method",
                    "rendered": {
                      "text": "TLS_method",
                      "markdown": "`TLS_method`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.Protocol.TLS.Hard-Coded"
            ]
          }
        },
        {
          "ruleId": "9c81a934-9274-35e2-b307-e5c625e3cee4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/uv/address.cc"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 15,
                  "endLine": 72,
                  "endColumn": 26,
                  "charOffset": 1785,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(str)",
                    "rendered": {
                      "text": "strlen(str)",
                      "markdown": "`strlen(str)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/uv/address.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1785,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(str, <size of str>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/uv/address.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1785,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(str, <size of str>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1f9f821c-e4b5-33c2-9bf2-09a7a880046e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/uv/address.cc"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 2,
                  "endLine": 37,
                  "endColumn": 44,
                  "charOffset": 863,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(bytes.data(), &impl_, sizeof(impl_)",
                    "rendered": {
                      "text": "memcpy(bytes.data(), &impl_, sizeof(impl_)",
                      "markdown": "`memcpy(bytes.data(), &impl_, sizeof(impl_)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/uv/address.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 863,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(bytes.data(), <size of bytes.data()>,  &impl_,  sizeof(impl_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2c388ac3-2043-37e1-bbf4-c45099d777bf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/uv/address.cc"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 2,
                  "endLine": 28,
                  "endColumn": 44,
                  "charOffset": 598,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(&impl_, bytes.data(), sizeof(impl_)",
                    "rendered": {
                      "text": "memcpy(&impl_, bytes.data(), sizeof(impl_)",
                      "markdown": "`memcpy(&impl_, bytes.data(), sizeof(impl_)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/uv/address.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 598,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&impl_, <size of &impl_>,  bytes.data(),  sizeof(impl_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e7ce36cb-52aa-3534-ac0c-f07a093e4fc2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/reduce.cc"
                },
                "region": {
                  "startLine": 56,
                  "startColumn": 6,
                  "endLine": 56,
                  "endColumn": 65,
                  "charOffset": 1777,
                  "charLength": 59,
                  "snippet": {
                    "text": "memcpy(out->ptr, in->ptr, opts.elements * opts.elementSize)",
                    "rendered": {
                      "text": "memcpy(out->ptr, in->ptr, opts.elements * opts.elementSize)",
                      "markdown": "`memcpy(out->ptr, in->ptr, opts.elements * opts.elementSize)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/reduce.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1777,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out->ptr, <size of out->ptr>,  in->ptr,  opts.elements * opts.elementSize)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "5b00e094-edfe-357c-b47f-652de84cbe24",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/pair.cc"
                },
                "region": {
                  "startLine": 778,
                  "startColumn": 47,
                  "endLine": 778,
                  "endColumn": 55,
                  "charOffset": 22257,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "381bd970-92bd-323f-a7e7-271694942b0e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/pair.cc"
                },
                "region": {
                  "startLine": 799,
                  "startColumn": 54,
                  "endLine": 799,
                  "endColumn": 62,
                  "charOffset": 22727,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "8ac08341-5db8-35f2-8733-b389f4b676e8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/pair.cc"
                },
                "region": {
                  "startLine": 589,
                  "startColumn": 61,
                  "endLine": 589,
                  "endColumn": 69,
                  "charOffset": 16652,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "6b665f15-2f96-3e9c-9ae1-251cbd1bc4a3",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/pair.cc"
                },
                "region": {
                  "startLine": 271,
                  "startColumn": 56,
                  "endLine": 271,
                  "endColumn": 64,
                  "charOffset": 7250,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "b4bd9cde-a788-3ebf-92a7-4a9d2e82495d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/pair.cc"
                },
                "region": {
                  "startLine": 395,
                  "startColumn": 55,
                  "endLine": 395,
                  "endColumn": 63,
                  "charOffset": 10328,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "7c6b43d4-d76c-367c-b952-eef692ba8dd3",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/pair.cc"
                },
                "region": {
                  "startLine": 254,
                  "startColumn": 55,
                  "endLine": 254,
                  "endColumn": 63,
                  "charOffset": 6715,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "fd75822b-078f-325a-bede-4725e9d9e9d8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/pair.cc"
                },
                "region": {
                  "startLine": 263,
                  "startColumn": 59,
                  "endLine": 263,
                  "endColumn": 67,
                  "charOffset": 7006,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "01432ad5-0c92-36cc-90c5-ed6faab06a4f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/pair.cc"
                },
                "region": {
                  "startLine": 162,
                  "startColumn": 55,
                  "endLine": 162,
                  "endColumn": 63,
                  "charOffset": 4078,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "1335673f-b0fc-3092-b762-9d794e45e49a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/pair.cc"
                },
                "region": {
                  "startLine": 185,
                  "startColumn": 55,
                  "endLine": 185,
                  "endColumn": 63,
                  "charOffset": 4725,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "6274f92c-0f62-3b0b-b06f-38daa190c1ec",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/pair.cc"
                },
                "region": {
                  "startLine": 170,
                  "startColumn": 59,
                  "endLine": 170,
                  "endColumn": 67,
                  "charOffset": 4348,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "2b40bb5d-1968-3b6a-8a40-8205f153de55",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/allreduce_ring.h"
                },
                "region": {
                  "startLine": 111,
                  "startColumn": 6,
                  "endLine": 111,
                  "endColumn": 40,
                  "charOffset": 3014,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                    "rendered": {
                      "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                      "markdown": "`memcpy(ptrs_[i], ptrs_[0], bytes_)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/allreduce_ring.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3014,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptrs_[i], <size of ptrs_[i]>,  ptrs_[0],  bytes_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "65e652d8-a70b-399d-8aa8-6532ada9c672",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/allreduce_ring.h"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 8,
                  "endLine": 98,
                  "endColumn": 39,
                  "charOffset": 2657,
                  "charLength": 31,
                  "snippet": {
                    "text": "memcpy(outbox_, inbox_, bytes_)",
                    "rendered": {
                      "text": "memcpy(outbox_, inbox_, bytes_)",
                      "markdown": "`memcpy(outbox_, inbox_, bytes_)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/allreduce_ring.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2657,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "memcpy_s(outbox_, <size of outbox_>,  inbox_,  bytes_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c101b4f5-a1bc-3fd9-b848-865b5539713d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/pair.cc"
                },
                "region": {
                  "startLine": 176,
                  "startColumn": 53,
                  "endLine": 176,
                  "endColumn": 61,
                  "charOffset": 4526,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4a839d0b-8d38-3b17-9084-483267e3781c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/allreduce_ring.h"
                },
                "region": {
                  "startLine": 80,
                  "startColumn": 4,
                  "endLine": 80,
                  "endColumn": 37,
                  "charOffset": 2129,
                  "charLength": 33,
                  "snippet": {
                    "text": "memcpy(outbox_, ptrs_[0], bytes_)",
                    "rendered": {
                      "text": "memcpy(outbox_, ptrs_[0], bytes_)",
                      "markdown": "`memcpy(outbox_, ptrs_[0], bytes_)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/allreduce_ring.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2129,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "memcpy_s(outbox_, <size of outbox_>,  ptrs_[0],  bytes_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "91199611-014a-3faf-bf9b-e0f43f77a6a7",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/device.cc"
                },
                "region": {
                  "startLine": 133,
                  "startColumn": 4,
                  "endLine": 133,
                  "endColumn": 12,
                  "charOffset": 3604,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "c04123ce-49c4-30c1-8a74-1c270ccefdc7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/device.cc"
                },
                "region": {
                  "startLine": 71,
                  "startColumn": 8,
                  "endLine": 71,
                  "endColumn": 61,
                  "charOffset": 1994,
                  "charLength": 53,
                  "snippet": {
                    "text": "memcpy(&attr.ai_addr, ifa->ifa_addr, attr.ai_addrlen)",
                    "rendered": {
                      "text": "memcpy(&attr.ai_addr, ifa->ifa_addr, attr.ai_addrlen)",
                      "markdown": "`memcpy(&attr.ai_addr, ifa->ifa_addr, attr.ai_addrlen)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/tcp/device.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1994,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&attr.ai_addr, <size of &attr.ai_addr>,  ifa->ifa_addr,  attr.ai_addrlen)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "887de324-11b9-3d76-b5ae-8d3cbc594548",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/device.cc"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 8,
                  "endLine": 49,
                  "endColumn": 61,
                  "charOffset": 1282,
                  "charLength": 53,
                  "snippet": {
                    "text": "memcpy(&attr.ai_addr, ifa->ifa_addr, attr.ai_addrlen)",
                    "rendered": {
                      "text": "memcpy(&attr.ai_addr, ifa->ifa_addr, attr.ai_addrlen)",
                      "markdown": "`memcpy(&attr.ai_addr, ifa->ifa_addr, attr.ai_addrlen)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/tcp/device.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1282,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&attr.ai_addr, <size of &attr.ai_addr>,  ifa->ifa_addr,  attr.ai_addrlen)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "484d3575-2f87-3dcc-84e1-8c128bb3c7d8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/device.cc"
                },
                "region": {
                  "startLine": 183,
                  "startColumn": 26,
                  "endLine": 183,
                  "endColumn": 34,
                  "charOffset": 5142,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4669bc03-2809-3a3b-96bc-a6a045fb9e3c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/device.cc"
                },
                "region": {
                  "startLine": 119,
                  "startColumn": 4,
                  "endLine": 119,
                  "endColumn": 54,
                  "charOffset": 3267,
                  "charLength": 50,
                  "snippet": {
                    "text": "memcpy(&attr.ai_addr, rp->ai_addr, rp->ai_addrlen)",
                    "rendered": {
                      "text": "memcpy(&attr.ai_addr, rp->ai_addr, rp->ai_addrlen)",
                      "markdown": "`memcpy(&attr.ai_addr, rp->ai_addr, rp->ai_addrlen)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/tcp/device.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3267,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&attr.ai_addr, <size of &attr.ai_addr>,  rp->ai_addr,  rp->ai_addrlen)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f6c4835d-7939-3d47-a95b-0bf2b378d2f2",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/device.cc"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 26,
                  "endLine": 31,
                  "endColumn": 34,
                  "charOffset": 719,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "cbbb9097-eeac-381b-8aca-af1ab01330f7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/device.cc"
                },
                "region": {
                  "startLine": 56,
                  "startColumn": 8,
                  "endLine": 56,
                  "endColumn": 61,
                  "charOffset": 1518,
                  "charLength": 53,
                  "snippet": {
                    "text": "memcpy(&attr.ai_addr, ifa->ifa_addr, attr.ai_addrlen)",
                    "rendered": {
                      "text": "memcpy(&attr.ai_addr, ifa->ifa_addr, attr.ai_addrlen)",
                      "markdown": "`memcpy(&attr.ai_addr, ifa->ifa_addr, attr.ai_addrlen)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/tcp/device.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1518,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&attr.ai_addr, <size of &attr.ai_addr>,  ifa->ifa_addr,  attr.ai_addrlen)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "99b5bbb1-0972-39b7-a50a-ca1db3c91146",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/uv/device.cc"
                },
                "region": {
                  "startLine": 96,
                  "startColumn": 8,
                  "endLine": 96,
                  "endColumn": 74,
                  "charOffset": 2309,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(&attr->ai_addr, &address.address6, sizeof(address.address6)",
                    "rendered": {
                      "text": "memcpy(&attr->ai_addr, &address.address6, sizeof(address.address6)",
                      "markdown": "`memcpy(&attr->ai_addr, &address.address6, sizeof(address.address6)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/uv/device.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2309,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&attr->ai_addr, <size of &attr->ai_addr>,  &address.address6,  sizeof(address.address6)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "be04ce1f-30aa-323d-a6c2-9c18527d80f7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/uv/device.cc"
                },
                "region": {
                  "startLine": 142,
                  "startColumn": 4,
                  "endLine": 142,
                  "endColumn": 54,
                  "charOffset": 3362,
                  "charLength": 50,
                  "snippet": {
                    "text": "memcpy(&attr.ai_addr, rp->ai_addr, rp->ai_addrlen)",
                    "rendered": {
                      "text": "memcpy(&attr.ai_addr, rp->ai_addr, rp->ai_addrlen)",
                      "markdown": "`memcpy(&attr.ai_addr, rp->ai_addr, rp->ai_addrlen)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/uv/device.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3362,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&attr.ai_addr, <size of &attr.ai_addr>,  rp->ai_addr,  rp->ai_addrlen)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "70501dc7-6198-3fcd-b90e-abb0768c8744",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Win32 - Hard-coded SSL/TLS Protocol"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/tls/openssl.cc"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 11,
                  "endLine": 52,
                  "endColumn": 37,
                  "charOffset": 1501,
                  "charLength": 26,
                  "snippet": {
                    "text": "SSL_CTX_set_security_level",
                    "rendered": {
                      "text": "SSL_CTX_set_security_level",
                      "markdown": "`SSL_CTX_set_security_level`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.Protocol.TLS.Hard-Coded"
            ]
          }
        },
        {
          "ruleId": "91e098d2-dc87-3d58-8be3-a7c4f2f5ba32",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Win32 - Hard-coded SSL/TLS Protocol"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/tls/openssl.cc"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 5,
                  "endLine": 51,
                  "endColumn": 31,
                  "charOffset": 1436,
                  "charLength": 26,
                  "snippet": {
                    "text": "SSL_CTX_set_security_level",
                    "rendered": {
                      "text": "SSL_CTX_set_security_level",
                      "markdown": "`SSL_CTX_set_security_level`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.Protocol.TLS.Hard-Coded"
            ]
          }
        },
        {
          "ruleId": "7f452c7a-5ed1-3695-9b0b-0da17a39298d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Win32 - Hard-coded SSL/TLS Protocol"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/tls/openssl.cc"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 11,
                  "endLine": 34,
                  "endColumn": 22,
                  "charOffset": 996,
                  "charLength": 11,
                  "snippet": {
                    "text": "SSL_CTX_new",
                    "rendered": {
                      "text": "SSL_CTX_new",
                      "markdown": "`SSL_CTX_new`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.Protocol.TLS.Hard-Coded"
            ]
          }
        },
        {
          "ruleId": "3f09ed87-c388-333a-b01d-4e208594f381",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Win32 - Hard-coded SSL/TLS Protocol"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/tls/openssl.cc"
                },
                "region": {
                  "startLine": 33,
                  "startColumn": 9,
                  "endLine": 33,
                  "endColumn": 20,
                  "charOffset": 945,
                  "charLength": 11,
                  "snippet": {
                    "text": "SSL_CTX_new",
                    "rendered": {
                      "text": "SSL_CTX_new",
                      "markdown": "`SSL_CTX_new`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.Protocol.TLS.Hard-Coded"
            ]
          }
        },
        {
          "ruleId": "55ef0220-6f55-35f7-8299-11461aff53cd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Win32 - Hard-coded SSL/TLS Protocol"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/tls/context.cc"
                },
                "region": {
                  "startLine": 91,
                  "startColumn": 12,
                  "endLine": 91,
                  "endColumn": 38,
                  "charOffset": 3456,
                  "charLength": 26,
                  "snippet": {
                    "text": "SSL_CTX_set_security_level",
                    "rendered": {
                      "text": "SSL_CTX_set_security_level",
                      "markdown": "`SSL_CTX_set_security_level`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.Protocol.TLS.Hard-Coded"
            ]
          }
        },
        {
          "ruleId": "1eeccbf6-ad54-366a-88b3-0eaa69aa73d1",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "OpenSSL: Do not hardcode SSL/TLS versions within an application."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/tls/context.cc"
                },
                "region": {
                  "startLine": 70,
                  "startColumn": 43,
                  "endLine": 70,
                  "endColumn": 71,
                  "charOffset": 2548,
                  "charLength": 28,
                  "snippet": {
                    "text": "SSL_OP_LEGACY_SERVER_CONNECT",
                    "rendered": {
                      "text": "SSL_OP_LEGACY_SERVER_CONNECT",
                      "markdown": "`SSL_OP_LEGACY_SERVER_CONNECT`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.Protocol.TLS.Hardcoded"
            ]
          }
        },
        {
          "ruleId": "b8946a09-890f-3f81-b801-1d74ff8a3bfd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Win32 - Hard-coded SSL/TLS Protocol"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/tls/context.cc"
                },
                "region": {
                  "startLine": 65,
                  "startColumn": 16,
                  "endLine": 65,
                  "endColumn": 45,
                  "charOffset": 2313,
                  "charLength": 29,
                  "snippet": {
                    "text": "SSL_CTX_set_min_proto_version",
                    "rendered": {
                      "text": "SSL_CTX_set_min_proto_version",
                      "markdown": "`SSL_CTX_set_min_proto_version`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.Protocol.TLS.Hard-Coded"
            ]
          }
        },
        {
          "ruleId": "f48a3879-2d76-3904-93b7-b80317f0aa7c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/uv/device.cc"
                },
                "region": {
                  "startLine": 89,
                  "startColumn": 8,
                  "endLine": 89,
                  "endColumn": 74,
                  "charOffset": 2038,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(&attr->ai_addr, &address.address4, sizeof(address.address4)",
                    "rendered": {
                      "text": "memcpy(&attr->ai_addr, &address.address4, sizeof(address.address4)",
                      "markdown": "`memcpy(&attr->ai_addr, &address.address4, sizeof(address.address4)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/uv/device.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2038,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&attr->ai_addr, <size of &attr->ai_addr>,  &address.address4,  sizeof(address.address4)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f60acd9d-4143-3a24-950e-f6b52ede8016",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/allreduce_local.cc"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 4,
                  "endLine": 36,
                  "endColumn": 38,
                  "charOffset": 859,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                    "rendered": {
                      "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                      "markdown": "`memcpy(ptrs_[i], ptrs_[0], bytes_)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/allreduce_local.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 859,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptrs_[i], <size of ptrs_[i]>,  ptrs_[0],  bytes_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3dbeca40-dd7d-3aa6-9fea-8092efc20793",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 361,
                  "startColumn": 16,
                  "endLine": 361,
                  "endColumn": 22,
                  "charOffset": 10827,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "ca63e922-baab-3e7d-995e-2aba08bfabba",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 339,
                  "startColumn": 44,
                  "endLine": 339,
                  "endColumn": 58,
                  "charOffset": 10404,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(optarg)",
                    "rendered": {
                      "text": "strlen(optarg)",
                      "markdown": "`strlen(optarg)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10404,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10404,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e3324a69-f358-32b9-a9e4-5d1091d390b7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/alltoallv.cc"
                },
                "region": {
                  "startLine": 142,
                  "startColumn": 2,
                  "endLine": 145,
                  "endColumn": 18,
                  "charOffset": 4678,
                  "charLength": 124,
                  "snippet": {
                    "text": "memcpy(\n      static_cast<char*>(out->ptr) + myOutOffset,\n      static_cast<char*>(in->ptr) + myInOffset,\n      myChunkSize)",
                    "rendered": {
                      "text": "memcpy(\n      static_cast<char*>(out->ptr) + myOutOffset,\n      static_cast<char*>(in->ptr) + myInOffset,\n      myChunkSize)",
                      "markdown": "`memcpy(\n      static_cast<char*>(out->ptr) + myOutOffset,\n      static_cast<char*>(in->ptr) + myInOffset,\n      myChunkSize)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/alltoallv.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4678,
                        "charLength": 124
                      },
                      "insertedContent": {
                        "text": "memcpy_s(\n      static_cast<char*>(out->ptr) + myOutOffset, <size of \n      static_cast<char*>(out->ptr) + myOutOffset>, \n      static_cast<char*>(in->ptr) + myInOffset, \n      myChunkSize)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "bd9fa479-fb9b-3b10-81fb-7dd0365b71ec",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 344,
                  "startColumn": 44,
                  "endLine": 344,
                  "endColumn": 58,
                  "charOffset": 10528,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(optarg)",
                    "rendered": {
                      "text": "strlen(optarg)",
                      "markdown": "`strlen(optarg)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10528,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10528,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2df6955a-5f11-3873-bf6a-8941b4726f3f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 324,
                  "startColumn": 26,
                  "endLine": 324,
                  "endColumn": 30,
                  "charOffset": 10045,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "8c776783-f0ff-305b-82ab-552b39fa1f66",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 319,
                  "startColumn": 48,
                  "endLine": 319,
                  "endColumn": 62,
                  "charOffset": 9938,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(optarg)",
                    "rendered": {
                      "text": "strlen(optarg)",
                      "markdown": "`strlen(optarg)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9938,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9938,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c3e5f9ba-c15a-34f0-9201-7a9e2e53342d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 314,
                  "startColumn": 22,
                  "endLine": 314,
                  "endColumn": 26,
                  "charOffset": 9809,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "f8a85ba7-f1fd-3a88-af26-840e6bd705cb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 334,
                  "startColumn": 42,
                  "endLine": 334,
                  "endColumn": 56,
                  "charOffset": 10280,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(optarg)",
                    "rendered": {
                      "text": "strlen(optarg)",
                      "markdown": "`strlen(optarg)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10280,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10280,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3cd67c0a-f7e1-3559-aa4c-3142d58d532f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 329,
                  "startColumn": 42,
                  "endLine": 329,
                  "endColumn": 56,
                  "charOffset": 10161,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(optarg)",
                    "rendered": {
                      "text": "strlen(optarg)",
                      "markdown": "`strlen(optarg)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10161,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10161,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f8a65901-b084-3031-b427-923f685177bb",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 304,
                  "startColumn": 29,
                  "endLine": 304,
                  "endColumn": 33,
                  "charOffset": 9600,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "2d364472-da6b-34b1-9c15-ee6bbe4b2598",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 299,
                  "startColumn": 30,
                  "endLine": 299,
                  "endColumn": 34,
                  "charOffset": 9494,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "81dbaff4-95d0-3e61-9921-7deb3c40a79c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 289,
                  "startColumn": 25,
                  "endLine": 289,
                  "endColumn": 29,
                  "charOffset": 9270,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "e2c7d5ed-7db2-3fda-8f80-d0a6339e9da8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 284,
                  "startColumn": 30,
                  "endLine": 284,
                  "endColumn": 34,
                  "charOffset": 9168,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "efacfc8b-173e-303f-adb3-d67aa6346442",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 238,
                  "startColumn": 32,
                  "endLine": 238,
                  "endColumn": 36,
                  "charOffset": 8140,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "a7692905-3771-3416-966a-7b1d4e8a0a9e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 269,
                  "startColumn": 24,
                  "endLine": 269,
                  "endColumn": 28,
                  "charOffset": 8852,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "24ab890a-c55a-33ed-952a-7adff6d4a167",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 262,
                  "startColumn": 10,
                  "endLine": 262,
                  "endColumn": 14,
                  "charOffset": 8671,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "5e38f064-f633-3c39-811e-5584912118a7",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 249,
                  "startColumn": 10,
                  "endLine": 249,
                  "endColumn": 14,
                  "charOffset": 8381,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "0d16502c-dac1-343a-8e9a-9ea348d9583b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 228,
                  "startColumn": 26,
                  "endLine": 228,
                  "endColumn": 30,
                  "charOffset": 7903,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "a54dd078-0b74-3e95-a2ea-156a49004713",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 233,
                  "startColumn": 38,
                  "endLine": 233,
                  "endColumn": 42,
                  "charOffset": 8023,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "9d8be6d3-e2ac-335a-b9c4-533c4b1541d0",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 205,
                  "startColumn": 27,
                  "endLine": 205,
                  "endColumn": 31,
                  "charOffset": 7388,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "7810f9db-7e92-3ebd-be8d-4010dd6c6b0d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 209,
                  "startColumn": 44,
                  "endLine": 209,
                  "endColumn": 58,
                  "charOffset": 7487,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(optarg)",
                    "rendered": {
                      "text": "strlen(optarg)",
                      "markdown": "`strlen(optarg)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7487,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7487,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "fdbe6aa7-0ddf-3415-8463-4a69dcc9e504",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 213,
                  "startColumn": 47,
                  "endLine": 213,
                  "endColumn": 61,
                  "charOffset": 7592,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(optarg)",
                    "rendered": {
                      "text": "strlen(optarg)",
                      "markdown": "`strlen(optarg)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7592,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7592,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c7d97622-b1ff-392c-86e3-92511e584f26",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 197,
                  "startColumn": 29,
                  "endLine": 197,
                  "endColumn": 33,
                  "charOffset": 7201,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "a9811300-2dc0-3a94-a43f-ba712fe27b8b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 201,
                  "startColumn": 47,
                  "endLine": 201,
                  "endColumn": 61,
                  "charOffset": 7303,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(optarg)",
                    "rendered": {
                      "text": "strlen(optarg)",
                      "markdown": "`strlen(optarg)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7303,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7303,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2a9155fa-0910-3e85-9ee8-c10809a0f46e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/address.cc"
                },
                "region": {
                  "startLine": 76,
                  "startColumn": 15,
                  "endLine": 76,
                  "endColumn": 26,
                  "charOffset": 1986,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(str)",
                    "rendered": {
                      "text": "strlen(str)",
                      "markdown": "`strlen(str)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/tcp/address.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1986,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(str, <size of str>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/tcp/address.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1986,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(str, <size of str>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "cba32b7f-4d97-34c0-8169-ceab94ddba9a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/address.cc"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 2,
                  "endLine": 55,
                  "endColumn": 44,
                  "charOffset": 1343,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(bytes.data(), &impl_, sizeof(impl_)",
                    "rendered": {
                      "text": "memcpy(bytes.data(), &impl_, sizeof(impl_)",
                      "markdown": "`memcpy(bytes.data(), &impl_, sizeof(impl_)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/tcp/address.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1343,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(bytes.data(), <size of bytes.data()>,  &impl_,  sizeof(impl_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ab8929f6-6b17-3a0c-bf43-f8532908fa4c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 193,
                  "startColumn": 29,
                  "endLine": 193,
                  "endColumn": 33,
                  "charOffset": 7117,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "502524ae-2967-3866-a3de-e61cff565aea",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/address.cc"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 43,
                  "endLine": 107,
                  "endColumn": 51,
                  "charOffset": 2805,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "84c31292-7681-3f25-b444-13ca03b04444",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/address.cc"
                },
                "region": {
                  "startLine": 46,
                  "startColumn": 2,
                  "endLine": 46,
                  "endColumn": 44,
                  "charOffset": 1078,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(&impl_, bytes.data(), sizeof(impl_)",
                    "rendered": {
                      "text": "memcpy(&impl_, bytes.data(), sizeof(impl_)",
                      "markdown": "`memcpy(&impl_, bytes.data(), sizeof(impl_)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/tcp/address.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1078,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&impl_, <size of &impl_>,  bytes.data(),  sizeof(impl_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "925eacb8-64c8-347c-8b89-09c6c3d4ccf8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/address.cc"
                },
                "region": {
                  "startLine": 97,
                  "startColumn": 43,
                  "endLine": 97,
                  "endColumn": 51,
                  "charOffset": 2547,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "147e01b3-93eb-3b70-a88c-e17130c827c2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Production Debug Code Presence\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/mpi/example/main_managed.cc"
                },
                "region": {
                  "startLine": 18,
                  "startColumn": 49,
                  "endLine": 18,
                  "endColumn": 58,
                  "charOffset": 497,
                  "charLength": 9,
                  "snippet": {
                    "text": "localhost",
                    "rendered": {
                      "text": "localhost",
                      "markdown": "`localhost`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Hygiene.Network.AccessingLocalhost"
            ]
          }
        },
        {
          "ruleId": "796c26a7-c265-3a6b-aff6-b75f8ef423b6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Production Debug Code Presence\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/mpi/example/main_unmanaged.cc"
                },
                "region": {
                  "startLine": 23,
                  "startColumn": 49,
                  "endLine": 23,
                  "endColumn": 58,
                  "charOffset": 561,
                  "charLength": 9,
                  "snippet": {
                    "text": "localhost",
                    "rendered": {
                      "text": "localhost",
                      "markdown": "`localhost`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Hygiene.Network.AccessingLocalhost"
            ]
          }
        },
        {
          "ruleId": "2964b590-e367-3b83-bf0b-0ef6a7ba8892",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/address.cc"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 2,
                  "endLine": 27,
                  "endColumn": 34,
                  "charOffset": 592,
                  "charLength": 32,
                  "snippet": {
                    "text": "memcpy(&impl_.ss, addr, addrlen)",
                    "rendered": {
                      "text": "memcpy(&impl_.ss, addr, addrlen)",
                      "markdown": "`memcpy(&impl_.ss, addr, addrlen)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/tcp/address.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 592,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&impl_.ss, <size of &impl_.ss>,  addr,  addrlen)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3e3dc112-dcaf-3b74-a4cf-b5adab26662e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/loop.cc"
                },
                "region": {
                  "startLine": 68,
                  "startColumn": 41,
                  "endLine": 68,
                  "endColumn": 49,
                  "charOffset": 1644,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "beae45ff-f160-3097-b4f3-484ade617825",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/loop.cc"
                },
                "region": {
                  "startLine": 73,
                  "startColumn": 41,
                  "endLine": 73,
                  "endColumn": 49,
                  "charOffset": 1816,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "dec4341d-62fc-34c2-ad1b-b8046dda5d15",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/loop.cc"
                },
                "region": {
                  "startLine": 45,
                  "startColumn": 45,
                  "endLine": 45,
                  "endColumn": 53,
                  "charOffset": 1146,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "ead99fcb-877b-30a8-acdd-70a6b681c402",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/allgatherv.cc"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 6,
                  "endLine": 110,
                  "endColumn": 19,
                  "charOffset": 3465,
                  "charLength": 141,
                  "snippet": {
                    "text": "memcpy(\n          static_cast<uint8_t*>(out->ptr) + byteOffsets[context->rank],\n          static_cast<uint8_t*>(in->ptr),\n          in->size)",
                    "rendered": {
                      "text": "memcpy(\n          static_cast<uint8_t*>(out->ptr) + byteOffsets[context->rank],\n          static_cast<uint8_t*>(in->ptr),\n          in->size)",
                      "markdown": "`memcpy(\n          static_cast<uint8_t*>(out->ptr) + byteOffsets[context->rank],\n          static_cast<uint8_t*>(in->ptr),\n          in->size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/allgatherv.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3465,
                        "charLength": 141
                      },
                      "insertedContent": {
                        "text": "memcpy_s(\n          static_cast<uint8_t*>(out->ptr) + byteOffsets[context->rank], <size of \n          static_cast<uint8_t*>(out->ptr) + byteOffsets[context->rank]>, \n          static_cast<uint8_t*>(in->ptr), \n          in->size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "19572b35-2996-3c12-ad9b-5dfbd5277446",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Production Debug Code Presence\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/examples/looks_like_mpi.cc"
                },
                "region": {
                  "startLine": 199,
                  "startColumn": 49,
                  "endLine": 199,
                  "endColumn": 58,
                  "charOffset": 4735,
                  "charLength": 9,
                  "snippet": {
                    "text": "localhost",
                    "rendered": {
                      "text": "localhost",
                      "markdown": "`localhost`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Hygiene.Network.AccessingLocalhost"
            ]
          }
        },
        {
          "ruleId": "698884a4-369f-39e7-a091-19a1f6de3cbd",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/examples/looks_like_mpi.cc"
                },
                "region": {
                  "startLine": 188,
                  "startColumn": 29,
                  "endLine": 188,
                  "endColumn": 35,
                  "charOffset": 4356,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}