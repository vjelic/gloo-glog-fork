{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "70501dc7-6198-3fcd-b90e-abb0768c8744",
              "name": "Win32HardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol: Win32 - Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440077"
                ]
              }
            },
            {
              "id": "91e098d2-dc87-3d58-8be3-a7c4f2f5ba32",
              "name": "Win32HardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol: Win32 - Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440077"
                ]
              }
            },
            {
              "id": "7f452c7a-5ed1-3695-9b0b-0da17a39298d",
              "name": "Win32HardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol: Win32 - Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440077"
                ]
              }
            },
            {
              "id": "3f09ed87-c388-333a-b01d-4e208594f381",
              "name": "Win32HardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol: Win32 - Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440077"
                ]
              }
            },
            {
              "id": "5b1d914b-6111-3d7d-9784-247efed9b924",
              "name": "Win32HardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol: Win32 - Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440077",
                  "5b1d914b-6111-3d7d-9784-247efed9b924"
                ]
              }
            },
            {
              "id": "9de769fa-27fe-3eee-af7c-28fd05ce9052",
              "name": "Win32HardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol: Win32 - Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440077",
                  "9de769fa-27fe-3eee-af7c-28fd05ce9052"
                ]
              }
            },
            {
              "id": "32b564e7-93ac-3290-a37e-99cb48d51ec8",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `strerror` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror`. Instead, use thread-safe alternatives such as `strerror_r` or `strerror_s`. Also, consider using higher-level abstractions provided by the C++ Standard Library, which are usually safer and less prone to errors.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror` function with `strerror_r` or `strerror_s`:\n\n```cpp\nchar buf[1024];\nGLOO_ENFORCE_EQ(rv, 0, \"rename: \", strerror_r(errno, buf, sizeof(buf)))\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `gloo`\n- `cstring`\n- `cerrno`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "d10ec77e-e94e-3bec-9984-e0c21d028e5c",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "3b6c98a0-2797-3c91-a03e-a4adea9071bb",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "60ae94fd-867d-3097-b5e0-5f0d88aafa4b",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "9c81a934-9274-35e2-b307-e5c625e3cee4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen` will continue reading memory beyond the intended boundary, leading to a buffer overflow. This can cause crashes, incorrect behavior, or even allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Be careful when manipulating strings, especially when using functions like `strcpy` or `strcat` that can overwrite the null terminator. Also, consider using safer alternatives to `strlen` that take a maximum length parameter, such as `strnlen`.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```c++\nlen = strlen(str);\n```\n\nYou could use:\n\n```c++\nlen = strnlen(str, MAX_LEN);\n```\n\nWhere `MAX_LEN` is the maximum expected length of the string. This will prevent `strnlen` from reading beyond this limit, even if `str` is not null-terminated.\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library, so no additional libraries are needed. The `strnlen` function is part of the POSIX library, so it may not be available on non-POSIX systems.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "55ef0220-6f55-35f7-8299-11461aff53cd",
              "name": "Win32HardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol: Win32 - Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440077"
                ]
              }
            },
            {
              "id": "bddc718a-4604-37ca-8b48-ea9fcaa9c3c3",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of C standard library functions that are known to be risky. These functions are often prohibited because they can lead to buffer overflow, format string vulnerabilities, or other types of security issues. In the provided code snippet, the function `strerror` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-thread-safe functions in multi-threaded environments. Instead, use thread-safe alternatives. For instance, instead of `strerror`, use `strerror_r` or `strerror_s` which are thread-safe.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror` function with `strerror_r` or `strerror_s`:\n\n```cpp\nchar errbuf[1024];\nstrerror_r(errno, errbuf, sizeof(errbuf));\nGLOO_ENFORCE_EQ(buf.data(), ret, \"realpath: \", errbuf);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstring` for `strerror`\n- `cerrno` for `errno`\n- `gloo` for `GLOO_ENFORCE_EQ`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "1eeccbf6-ad54-366a-88b3-0eaa69aa73d1",
              "name": "OpensslDoNotHardcodeSsltlsVersionsWithinAnApplication",
              "shortDescription": {
                "text": "SSL/TLS version usage should be based on an OS or external configuration."
              },
              "fullDescription": {
                "text": "OpenSSL: Do not hardcode SSL/TLS versions within an application.: SSL/TLS version usage should be based on an OS or external configuration."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "SSL/TLS version usage should be based on an OS or external configuration.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "warning",
                "tags": [
                  "DS440010"
                ]
              }
            },
            {
              "id": "b8946a09-890f-3f81-b801-1d74ff8a3bfd",
              "name": "Win32HardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol: Win32 - Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440077",
                  "b8946a09-890f-3f81-b801-1d74ff8a3bfd"
                ]
              }
            },
            {
              "id": "b8946a09-890f-3f81-b801-1d74ff8a3bfd",
              "name": "OpensslDoNotHardcodeSsltlsVersionsWithinAnApplication",
              "shortDescription": {
                "text": "SSL/TLS version usage should be based on an OS or external configuration."
              },
              "fullDescription": {
                "text": "OpenSSL: Do not hardcode SSL/TLS versions within an application.: SSL/TLS version usage should be based on an OS or external configuration."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "SSL/TLS version usage should be based on an OS or external configuration.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "warning",
                "tags": [
                  "DS440010"
                ]
              }
            },
            {
              "id": "b8946a09-890f-3f81-b801-1d74ff8a3bfd",
              "name": "OpensslHardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "OpenSSL: Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "OpenSSL: Hard-coded SSL/TLS Protocol: OpenSSL: Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440001.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440001.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440001.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440011"
                ]
              }
            },
            {
              "id": "4e288d1a-50e0-3418-84ca-566448b856cb",
              "name": "Win32HardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol: Win32 - Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440077",
                  "4e288d1a-50e0-3418-84ca-566448b856cb"
                ]
              }
            },
            {
              "id": "c257b456-63b5-3a07-b942-5fbd7b94fc69",
              "name": "Win32HardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol: Win32 - Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440077",
                  "c257b456-63b5-3a07-b942-5fbd7b94fc69"
                ]
              }
            },
            {
              "id": "2c388ac3-2043-37e1-bbf4-c45099d777bf",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is a risk that the source pointer could be null at runtime, since there is no prior check ensuring it is valid. The destination is not likely to be null, but the overlap and null source risks make this a high-confidence issue. The operation does not include any explicit bounds or null-termination handling, and the use of memcpy in this context can lead to unpredictable results or crashes if the overlap occurs.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\nExample remediation:\n\n```cpp\nif (bytes.data() != nullptr) {\n    memmove(&impl_, bytes.data(), sizeof(impl_));\n}\n```\n\nThis change replaces `memcpy` with `memmove` and adds a null check for the source pointer. This ensures safe copying even if the memory regions overlap and prevents undefined behavior due to a null source pointer.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "1f9f821c-e4b5-33c2-9bf2-09a7a880046e",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, both the source and destination pointers may be null at this call site, and there are no explicit guards to prevent this. The use of a direct memory copy function without overlap protection in such a scenario can lead to unpredictable program behavior, crashes, or security vulnerabilities. The absence of explicit bounds checks or null pointer guards further increases the risk.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use a function that is safe for overlapping memory, such as `memmove`, instead of `memcpy`. Additionally, ensure that both the source and destination pointers are not null before performing the copy operation. For example:\n\n```cpp\nif (bytes.data() != nullptr && &impl_ != nullptr) {\n    memmove(bytes.data(), &impl_, sizeof(impl_));\n}\n```\nThis change ensures that the copy operation is safe even if the source and destination overlap, and avoids dereferencing null pointers.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ead99fcb-877b-30a8-acdd-70a6b681c402",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers are derived from potentially related structures, and dataflow analysis suggests that they may overlap. Additionally, the source pointer may be null, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the function used (`memcpy`) does not handle overlapping memory regions safely. This combination of factors makes the issue a high-confidence, actionable problem that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation 0\nTo prevent undefined behavior when the source and destination memory regions may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to safely handle overlapping regions, whereas `memcpy` is not. Replace the original call with `memmove`:\n\n```cpp\nmemmove(static_cast<uint8_t*>(out->ptr) + byteOffsets[context->rank], static_cast<uint8_t*>(in->ptr), in->size);\n```\n\nThis change ensures that the memory copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n## In Context Remediation 1\nBefore performing the memory copy, add explicit checks to ensure that the source pointer is not null and that the size is valid. This helps prevent undefined behavior due to null pointer dereference:\n\n```cpp\nif (in->ptr != nullptr && in->size > 0) {\n    memmove(static_cast<uint8_t*>(out->ptr) + byteOffsets[context->rank], static_cast<uint8_t*>(in->ptr), in->size);\n}\n```\n\nThis approach adds a guard to prevent copying from a null source pointer and ensures that the operation only occurs when there is data to copy.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "be04ce1f-30aa-323d-a6c2-9c18527d80f7",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis detected that the source and destination may overlap based on data flow, which can cause unpredictable results with functions like memcpy. Additionally, there is a risk that the source pointer may be null, as there is no prior check ensuring it is valid. The destination is not likely to be null, but the overlap and null source risks make this a high-confidence, actionable issue. No explicit length or bounds checks are present, and the count argument is not derived from the destination's capacity, further increasing the risk.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n```cpp\nif (rp->ai_addr != nullptr) {\n    memmove(&attr.ai_addr, rp->ai_addr, rp->ai_addrlen);\n}\n```\n\nThis change replaces `memcpy` with `memmove` and adds a null check for the source pointer. This ensures safe copying even if the regions overlap and prevents undefined behavior if the source is null.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [NIST Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "f48a3879-2d76-3904-93b7-b80317f0aa7c",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions. The analysis detected that the destination and source may refer to overlapping memory, which can cause undefined behavior when using functions like memcpy. Additionally, the source may be null at this call site, which further increases the risk. There are no explicit guards or checks to prevent these issues, and the function call is not protected by any bounds or overlap checks. The destination is not likely to be null, but the overlap and possible null source make this a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely. Replace the original call with:\n\n```cpp\nmemmove(&attr->ai_addr, &address.address4, sizeof(address.address4));\n```\n\nThis change ensures that the copy operation is safe even if the source and destination overlap.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "99b5bbb1-0972-39b7-a50a-ca1db3c91146",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that overlap is feasible based on data flow between the destination and source, which can cause undefined behavior with functions like memcpy. Additionally, the source may be null at this call site, which further increases the risk. There are no explicit guards or null-termination after the copy, and the destination's capacity is not clearly defined. These factors all contribute to the assessment that this is a real and actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely. Replace the original call with:\n\n```cpp\nmemmove(&attr->ai_addr, &address.address6, sizeof(address.address6));\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e3324a69-f358-32b9-a9e4-5d1091d390b7",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The dataflow analysis indicates that the destination and source may refer to overlapping memory, which is not allowed for the standard memory copy function used here. Additionally, the source pointer may be null at this call site, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the size of the memory region being copied is not derived from the capacity of the destination buffer. These factors all contribute to the high confidence in this being a real issue that could lead to memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the standard memory copy function with a function that safely handles overlapping regions. In C and C++, use `memmove` instead of `memcpy` for such cases. `memmove` is designed to correctly handle overlapping memory areas.\n\n**Remediation Example:**\n\n```cpp\nmemmove(static_cast<char*>(out->ptr) + myOutOffset, static_cast<char*>(in->ptr) + myInOffset, myChunkSize);\n```\n\nThis change ensures that the memory copy operation is safe even if the source and destination regions overlap. Additionally, consider adding checks to ensure that the source pointer is not null before performing the operation to avoid null pointer dereference.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "5b9d4dc7-d487-32d6-afbc-c67162d0f5aa",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `strerror()` is used which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives like `strerror_r()` in POSIX or `strerror_s()` in Windows. Always validate and sanitize input data before processing. Use secure coding practices and follow the principle of least privilege.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with `strerror_r()`:\n\n```cpp\nchar buf[1024];\nGLOO_ENFORCE_EQ(rv, 0, \"ibv_query_port: \", strerror_r(errno, buf, sizeof(buf)))\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `errno.h`: For `errno` and `strerror()`.\n- `string.h`: For `strerror_r()`.\n- `gloo/Enforce.h`: For `GLOO_ENFORCE_EQ()`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "e990d1b0-94b0-3314-bbc6-547842df8848",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions in the code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of using `strerror()`, use `strerror_r()` which is a thread-safe version of `strerror()`. \n\n## Source Code Fix Recommendation\n\nHere is the recommended fix for the provided code snippet:\n\n```cpp\nchar buf[1024];\nGLOO_ENFORCE_EQ(rv, 0, \"ibv_query_device: \", strerror_r(errno, buf, sizeof(buf)))\n```\n\n## Library Dependencies\n\nThe code snippet seems to be using the following libraries:\n\n- Gloo: A collective communications library.\n- InfiniBand Verbs (ibv): A library for hardware RDMA (Remote Direct Memory Access) and channel I/O operations.\n- C Standard Library (for `strerror()` function and `errno`)\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-676): Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "2b40bb5d-1968-3b6a-8a40-8205f153de55",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The source and destination pointers are derived from the same array or data structure, and dataflow analysis suggests that they may refer to overlapping memory areas. Additionally, the source pointer may be null, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the classification and verdict both indicate a high-confidence, actionable problem.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely, whereas `memcpy` is not. Replace the original call with:\n\n```cpp\nmemmove(ptrs_[i], ptrs_[0], bytes_);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "6c86517b-7edb-3fc1-b7cd-cd26cf5b2d5d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(data.get(), &t, sizeof(T))`, there is no check to ensure that the size of `T` is not larger than the size of the buffer pointed to by `data.get()`. If `T` is larger, this could lead to a buffer overflow, which could potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`. If the data is too large, you should handle this error condition appropriately, for example by truncating the data or by allocating a larger buffer.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code snippet:\n\n```cpp\nif (sizeof(T) <= data.size()) {\n    memcpy(data.get(), &t, sizeof(T));\n} else {\n    // Handle error condition here\n}\n```\n\nIn this fixed code, we first check if the size of `T` is less than or equal to the size of the buffer. If it is, we proceed with the `memcpy`. If it is not, we handle the error condition.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "65e652d8-a70b-399d-8aa8-6532ada9c672",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions. The analysis detected that both the source and destination are members of the same object (indicated by 'same base identifier: this'), which increases the likelihood of overlap. Additionally, there are no explicit checks ensuring that the source and destination pointers are non-null, which further increases the risk of undefined behavior. The verdict for this call site is marked as 'GENUINE', confirming the high confidence in this issue. No evidence was found to suggest that this is a false positive, and the risk of undefined behavior is significant in this context.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Additionally, ensure that both the source and destination pointers are not null before performing the copy operation. For example:\n\n```cpp\nif (outbox_ != nullptr && inbox_ != nullptr) {\n    memmove(outbox_, inbox_, bytes_);\n}\n```\n\nThis change ensures that the copy operation is safe even if the memory regions overlap, and it avoids dereferencing null pointers.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "4a839d0b-8d38-3b17-9084-483267e3781c",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The source and destination pointers may refer to overlapping memory, as indicated by the data flow analysis. Additionally, there is a risk that either the source or destination pointer could be null, as there are no clear checks or guards in place to prevent this. The absence of explicit bounds checks or null pointer validation further increases the risk. These factors make this a high-confidence, actionable issue that could lead to unpredictable program behavior, crashes, or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, validate that both the source and destination pointers are not null before performing the copy operation.\n\n```cpp\nif (outbox_ != nullptr && ptrs_[0] != nullptr) {\n    // Use memmove instead of memcpy to safely handle possible overlap\n    memmove(outbox_, ptrs_[0], bytes_);\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "747b0f17-b737-3655-b140-dd9042a2a08a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with memcpy. Additionally, the source pointer may be null, which could also lead to a crash or further undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the length parameter is not derived from a known safe capacity. These factors all contribute to the high confidence in this being a real and actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(static_cast<uint8_t*>(out[i]->ptr) + offset, static_cast<const uint8_t*>(out[0]->ptr) + offset, length);\n```\n\nAdditionally, ensure that both source and destination pointers are valid and not null before performing the operation. For example:\n\n```cpp\nif (out[i] && out[i]->ptr && out[0] && out[0]->ptr) {\n    memmove(static_cast<uint8_t*>(out[i]->ptr) + offset, static_cast<const uint8_t*>(out[0]->ptr) + offset, length);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a7f3d54b-4233-37e4-b03c-38cd2d7c9448",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers are derived from potentially related data structures, and dataflow analysis suggests that they may alias each other. Additionally, the source pointer may be null, which could also result in undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the length parameter is not derived from a known safe capacity. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to safely handle overlapping memory areas. Replace the original call with:\n\n```cpp\nmemmove(static_cast<uint8_t*>(out[0]->ptr) + offset, static_cast<const uint8_t*>(in[0]->ptr) + offset, length);\n```\n\nAdditionally, ensure that the `length` parameter does not exceed the bounds of either the source or destination buffers, and validate that neither pointer is null before performing the operation.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e835e09a-adbf-30b4-86ee-6d8ed836cce5",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The code copies data from one buffer to another using a memory copy function, but dataflow analysis indicates that the source and destination may refer to overlapping memory regions. This can result in unpredictable behavior, data corruption, or crashes. Additionally, there are no checks to ensure that the source and destination pointers are non-null, which could lead to null pointer dereference vulnerabilities. The absence of explicit bounds checks or guards further increases the risk. These factors make this a high-confidence, actionable issue that should be addressed to ensure memory safety.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use a memory move function that is designed to handle overlapping regions safely. Additionally, add explicit checks to ensure that both the source and destination pointers are not null before performing the operation. For example:\n\n```cpp\nif (address.data() != nullptr && out.data() != nullptr) {\n    std::memmove(address.data(), out.data() + offset, maxLength);\n}\n```\nThis change replaces the memory copy function with a memory move function, which is safe for overlapping regions, and adds null pointer checks to prevent dereferencing null pointers.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "1d58d372-6232-3ff1-b0a4-fa784a1e3558",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers may refer to overlapping memory, as indicated by the data flow analysis. Additionally, there are no explicit checks to ensure that the source and destination are non-null, which increases the risk of null pointer dereference. The absence of bounds checks or guards further increases the risk of memory safety issues. The verdict is supported by the classification and the high-confidence 'GENUINE' label from the analysis.\n\n## In Context Remediation\nTo prevent undefined behavior when using memory copy operations, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use a function that is safe for overlapping regions, such as `memmove`, instead of `memcpy`. Additionally, add explicit checks to ensure that neither the source nor the destination pointers are null before performing the copy operation.\n\n**Remediation Example:**\n\n```cpp\n// Check for null pointers\nif (in.data() != nullptr && address.data() != nullptr) {\n    // Use memmove instead of memcpy if overlap is possible\n    memmove(in.data() + (i * maxLength), address.data(), address.size());\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "9d10efac-857c-3038-b157-da0b4779f409",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of functions or methods that generate random numbers which are not suitable for security-critical operations. The `rand()` function, for example, is a weak random number generator because it produces predictable numbers and is not cryptographically secure. This can lead to various security issues, such as predictability in password generation, session identifiers, or cryptographic keys, which can be exploited by attackers.\n\nIn the given code snippet, `rand() & 0xffffff` is used to generate a random number, which is a weak random number generator.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographically secure random number generator. In C++, you can use functions provided by libraries like `<random>` or `<cryptopp>`.\n\n## Source Code Fix Recommendation\n\nReplace the `rand()` function with a cryptographically secure random number generator. Here is an example using the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(0, 0xffffff);\n\nself_.addr_.psn = dis(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "32c68edd-8bdd-38af-bac6-bb47cce4eec6",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers are derived from the same array or data structure, and dataflow analysis suggests that they may refer to overlapping memory. This can cause undefined behavior when using functions like memcpy. Additionally, the analysis could not rule out the possibility that the source pointer is null, which could also lead to a crash or further undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the function does not ensure that the memory regions are distinct or that the source is non-null. These factors indicate a real risk that should be addressed.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. The `memmove` function is designed to handle overlapping memory safely, whereas `memcpy` is not. Replace the original call with:\n\n```cpp\nmemmove(ptrs_[i], ptrs_[0], bytes_);\n```\n\nAdditionally, ensure that both `ptrs_[i]` and `ptrs_[0]` are not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (ptrs_[i] != nullptr && ptrs_[0] != nullptr) {\n    memmove(ptrs_[i], ptrs_[0], bytes_);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "796c26a7-c265-3a6b-aff6-b75f8ef423b6",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Production Debug Code Presence\" vulnerability refers to the situation where debug code is accidentally left in the production environment. This can lead to a variety of security issues, including unauthorized access, information disclosure, and even remote code execution. In C++ programming, this vulnerability can occur if the debug code is not properly managed and removed before the application is deployed in a production environment.\n\nIn the provided code snippet, the `gloo::transport::tcp::CreateDevice(\"localhost\")` function is used, which might be part of a debug code. If this code is left in the production environment, it could potentially expose sensitive information or allow unauthorized access.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n- Always remove debug code or any code that is not necessary for the production environment before deploying the application.\n- Use preprocessor directives to ensure that debug code is not compiled into the final production build.\n- Regularly review and audit the code to ensure that no debug code is left in the production environment.\n- Use automated tools to detect and remove debug code.\n\n## Source Code Fix Recommendation\n\nThe fix would involve removing the debug code or wrapping it with preprocessor directives. Here is an example:\n\n```cpp\n#ifndef NDEBUG\ndev = gloo::transport::tcp::CreateDevice(\"localhost\")\n#endif\n```\n\nIn this example, the debug code will only be compiled if the `NDEBUG` macro is not defined. This macro is usually not defined in the production build, so the debug code will be excluded.\n\n## Library Dependencies\n\nThe provided code snippet seems to be using the Gloo library for collective communications over TCP. Therefore, the Gloo library would be a required dependency.\n\n## References\n\n- [CWE-489: Leftover Debug Code](https://cwe.mitre.org/data/definitions/489.html)\n\nPlease note that the links provided are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS162092"
                ]
              }
            },
            {
              "id": "e74731a3-1100-3620-890c-049fcc560564",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers are derived from the same array or data structure, and dataflow analysis suggests that they may refer to overlapping memory. Additionally, the source pointer may be null, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely, whereas `memcpy` is not. Replace the original call with:\n\n```cpp\nmemmove(ptrs_[i], ptrs_[0], bytes_);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a3ae97a0-d037-3150-b643-6e08ea17a265",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are derived from potentially related data structures, and dataflow analysis suggests that the destination may be derived from the source, which can lead to overlapping memory regions. The use of a standard memory copy function (such as memcpy) in this context is unsafe if the regions overlap, as this results in undefined behavior according to the C/C++ standards. Additionally, the analysis could not rule out the possibility that the source pointer may be null, which further increases the risk. There are no explicit guards or checks in the code to prevent these issues, and the classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the standard memory copy function with a function that is safe for overlapping regions, such as `memmove`. This function correctly handles overlapping memory by ensuring that the copy is performed in a way that avoids data corruption. For example, change the code to use `std::memmove` instead of `std::memcpy`:\n\n```cpp\nstd::memmove(&ptrs_[0][ptrOffset], &recvBufs_[recvBufIdx_[srcRank]][0], recvCount * sizeof(T));\n```\n\nThis change ensures that even if the source and destination regions overlap, the operation will be performed safely and without undefined behavior.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "0f7aa0f9-94ab-3b02-8d97-2fd1153da301",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the use of non-cryptographic or weak random number generators can lead to vulnerabilities. This is because these generators can produce predictable outcomes, which can be exploited by attackers. In the given code snippet, `rand()` is a weak random number generator as it uses a deterministic algorithm.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are more secure than `rand()`. \n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(0, minDistanceCount - 1);\n\nminOffset = dis(gen);\n```\n\nIn this code, `std::random_device` is a non-deterministic random number generator, and `std::mt19937` is a Mersenne Twister: a strong pseudo-random number generator. `std::uniform_int_distribution` is used to ensure the generated number is within the desired range.\n\n## Library Dependencies\n\nThe fixed code requires the `<random>` library.\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "0f7aa0f9-94ab-3b02-8d97-2fd1153da301"
                ]
              }
            },
            {
              "id": "147e01b3-93eb-3b70-a88c-e17130c827c2",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Production Debug Code Presence\" vulnerability refers to the situation where debug code is accidentally left in the production environment. This can lead to a variety of security issues, including unauthorized access, information disclosure, and even remote code execution. In C++ programming, this vulnerability can occur if the debug code is not properly managed and removed before the application is deployed in a production environment.\n\nIn the provided code snippet, the `gloo::transport::tcp::CreateDevice(\"localhost\")` function is used, which might be part of a debug code. If this code is left in the production environment, it could potentially expose sensitive information or allow unauthorized access.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n- Always remove debug code or any code that is not necessary for the production environment before deploying the application.\n- Use preprocessor directives to ensure that debug code is not compiled into the final production build.\n- Regularly review and audit the code to ensure that no debug code is left in the production environment.\n- Use automated tools to detect and remove debug code.\n\n## Source Code Fix Recommendation\n\nThe fix would involve removing the debug code or wrapping it with preprocessor directives. Here is an example:\n\n```cpp\n#ifndef NDEBUG\ndev = gloo::transport::tcp::CreateDevice(\"localhost\")\n#endif\n```\n\nIn this example, the debug code will only be compiled if the `NDEBUG` macro is not defined. This macro is usually not defined in the production build, so the debug code will be excluded.\n\n## Library Dependencies\n\nThe provided code snippet seems to be using the Gloo library for collective communications over TCP. Therefore, the Gloo library would be a required dependency.\n\n## References\n\n- [CWE-489: Leftover Debug Code](https://cwe.mitre.org/data/definitions/489.html)\n\nPlease note that the links provided are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS162092"
                ]
              }
            },
            {
              "id": "b1a5f6a6-ff53-3c5e-98db-634cb388b4be",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the use of non-cryptographic or weak random number generators can lead to vulnerabilities. This is because these generators can produce predictable outcomes, which can be exploited by attackers. In the given code snippet, `rand()` is a weak random number generator as it uses a deterministic algorithm.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are more secure than `rand()`. \n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(0, minDistanceCount - 1);\n\nminOffset = dis(gen);\n```\n\nIn this code, `std::random_device` is a non-deterministic random number generator, and `std::mt19937` is a Mersenne Twister: a strong pseudo-random number generator. `std::uniform_int_distribution` is used to ensure the generated number is within the desired range.\n\n## Library Dependencies\n\nThe fixed code requires the `<random>` library.\n\n## References\n\n- [OWASP - Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness)\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "b1a5f6a6-ff53-3c5e-98db-634cb388b4be"
                ]
              }
            },
            {
              "id": "eede7331-8419-3259-a8f7-191a3218c5dd",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers may refer to overlapping memory, as indicated by the dataflow analysis. This can lead to unpredictable results or program crashes, since the standard memory copy function does not guarantee correct behavior when regions overlap. There are no explicit checks or guards in the code to prevent this overlap, and the function verdict confirms the issue as genuine. The source and destination are both non-null, so null pointer dereference is not a concern here. The main risk is the undefined behavior from overlapping memory regions.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the standard memory copy function with a function that safely handles overlapping regions. In C/C++, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping memory correctly. \n\n**Remediation example:**\n\n```cpp\nmemmove(static_cast<char*>(out->ptr) + (context->rank * chunkSize), in->ptr, chunkSize);\n```\n\nThis change ensures that even if the source and destination regions overlap, the data will be copied safely without causing undefined behavior.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ab8825d0-704c-377a-9746-7767c4fa5acf",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are derived from related data structures, and dataflow analysis suggests that they may refer to overlapping memory. Additionally, the source pointer could potentially be null, which would also result in undefined behavior. There are no explicit checks or guards in the code to prevent these issues. The classification and verdict both indicate a high-confidence, actionable issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. For example, replace the original call with:\n\n```cpp\nmemmove(outPtr_ + rank * inputStride_ + i * count_, inPtrs_[i], bytes_);\n```\n\nAdditionally, consider adding explicit checks to ensure that the source pointer is not null before performing the copy:\n\n```cpp\nif (inPtrs_[i] != nullptr) {\n    memmove(outPtr_ + rank * inputStride_ + i * count_, inPtrs_[i], bytes_);\n}\n```\n\nThis approach mitigates both the risk of undefined behavior due to overlapping memory and null pointer dereference.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "502524ae-2967-3866-a3de-e61cff565aea",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives like `strerror_r()` in POSIX or `strerror_s()` in Windows. Also, consider using higher-level abstractions provided by the C++ Standard Library, which are usually safer and less error-prone.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with its thread-safe counterpart `strerror_r()`:\n\n```cpp\nchar buf[1024];\nGLOO_ENFORCE_NE(rv, -1, \"getpeername: \", strerror_r(errno, buf, sizeof(buf)))\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `errno.h`: for `errno`\n- `string.h`: for `strerror()`\n- `gloo/Enforce.h`: for `GLOO_ENFORCE_NE()`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "925eacb8-64c8-347c-8b89-09c6c3d4ccf8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use thread-safe alternatives to these insecure C library functions. In the case of `strerror()`, the thread-safe alternative is `strerror_r()`.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with `strerror_r()` in the provided code snippet:\n\n```cpp\nchar buf[1024];\nGLOO_ENFORCE_NE(rv, -1, \"getsockname: \", strerror_r(errno, buf, sizeof(buf)))\n```\n\n## Library Dependencies\n\nThe provided code snippet requires the following libraries:\n\n- `errno.h`: for the `errno` variable\n- `string.h`: for the `strerror()` function\n- `gloo/Enforce.h`: for the `GLOO_ENFORCE_NE()` macro\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "2a9155fa-0910-3e85-9ee8-c10809a0f46e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen` will continue reading memory beyond the intended boundary, leading to a buffer overflow. This can cause crashes, incorrect behavior, or even allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Be careful when manipulating strings, especially when using functions like `strcpy` or `strcat` that can overwrite the null terminator. Also, consider using safer alternatives to `strlen` that take a maximum length parameter, such as `strnlen`.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```c++\nlen = strlen(str);\n```\n\nYou could use:\n\n```c++\nlen = strnlen(str, MAX_LEN);\n```\n\nWhere `MAX_LEN` is the maximum expected length of the string. This will prevent `strnlen` from reading beyond this limit, even if `str` is not null-terminated.\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library, so no additional libraries are needed. The `strnlen` function is part of the POSIX library, so it may not be available on non-POSIX systems.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "cba32b7f-4d97-34c0-8169-ceab94ddba9a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis found that the source and destination may overlap based on data flow, which can cause unpredictable results with memcpy. Additionally, both the source and destination pointers may be null at this call site, increasing the risk of runtime errors. There are no explicit guards or checks to prevent these issues, and the size argument is not derived from the destination's capacity. This combination of factors makes the issue highly likely to be a real vulnerability that could lead to memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that neither the source nor the destination pointers are null before performing the copy to avoid null pointer dereference.\n\n```cpp\nif (bytes.data() != nullptr && &impl_ != nullptr) {\n    memmove(bytes.data(), &impl_, sizeof(impl_));\n}\n```\n\nIf you are certain that the regions never overlap, document this assumption clearly in the code and add runtime assertions if possible. Otherwise, prefer `memmove` for safety.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "84c31292-7681-3f25-b444-13ca03b04444",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memcpy operation. The dataflow analysis indicates that the destination and source may refer to overlapping memory, which is not allowed for memcpy and can result in unpredictable program behavior. Additionally, there is a risk that the source pointer may be null at this call site, as there is no prior check ensuring it is non-null. The destination is not likely to be null, but the overlap and null source risks make this a high-confidence issue. No explicit bounds or guards are present to mitigate these risks.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n```cpp\nif (bytes.data() != nullptr) {\n    memmove(&impl_, bytes.data(), sizeof(impl_));\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [NIST Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "2964b590-e367-3b83-bf0b-0ef6a7ba8892",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence of a guard to ensure the source is non-null, which further increases the risk. The destination is not a pointer-based member, reducing the risk of it being null, but the source may still be null. The classification and verdict both indicate a high-confidence issue that should be addressed to prevent undefined behavior and potential security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add a check to ensure the source pointer is not null before performing the copy operation.\n\n```cpp\nif (addr != nullptr) {\n    memmove(&impl_.ss, addr, addrlen);\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "0218fb85-96b2-3ce6-b9f5-d39d55ddb8ad",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers are derived from potentially related data structures, and dataflow analysis suggests that they may overlap. Additionally, the source pointer could be null, which would also result in undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the function used (`memcpy`) does not handle overlapping memory regions safely. This combination of factors makes the issue a high-confidence, actionable problem that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to safely handle overlapping regions. This change ensures that the copy operation will not corrupt data if the regions overlap.\n\n```cpp\nmemmove(static_cast<uint8_t*>(out->ptr) + context->rank * in->size, static_cast<uint8_t*>(in->ptr), in->size);\n```\n\nAdditionally, consider adding explicit checks to ensure that the source pointer is not null before performing the copy operation:\n\n```cpp\nif (in->ptr != nullptr) {\n    memmove(static_cast<uint8_t*>(out->ptr) + context->rank * in->size, static_cast<uint8_t*>(in->ptr), in->size);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3e0a80e5-ee0c-3529-b531-c68c8cfb1129",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to the possibility that either the source or destination pointer may be null at the point of the memory copy operation. The verdict for this call site is also marked as 'GENUINE', confirming the high confidence in the issue. The source is a C-style string, which is generally safe, but the analysis indicates that the destination pointer may be null and there are no explicit checks to prevent this. Additionally, there is no evidence of a guard condition that would ensure the destination is valid before the copy. While a null terminator is written after the copy, this does not mitigate the risk of dereferencing a null pointer. Therefore, the risk of undefined behavior is real and should be addressed.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that both the destination and source pointers are not null. This prevents undefined behavior due to null pointer dereference. For example:\n\n```cpp\nif (ifr.ifr_name != nullptr && ifname.c_str() != nullptr) {\n    memcpy(ifr.ifr_name, ifname.c_str(), len);\n    // ...\n}\nelse {\n    // Handle error: one or both pointers are null\n}\n```\n\nAlternatively, if `ifr.ifr_name` is a fixed-size array (as is typical for `struct ifreq`), ensure that the structure is properly initialized and not a dangling pointer. Always validate input and initialization paths to guarantee pointer validity.\n\n## References\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "75d86a64-ff64-3127-a451-b7688bf6e570",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives such as `strerror_r()` in POSIX or `strerror_s()` in Windows. Always ensure that your code is thread-safe to prevent race conditions.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with `strerror_r()` or `strerror_s()` depending on your platform. Here is an example of how you can do it:\n\n```cpp\nchar buf[1024];\n#if (_POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600) && ! _GNU_SOURCE\n    strerror_r(errno, buf, sizeof(buf));\n#else\n    char *msg = strerror_r(errno, buf, sizeof(buf));\n#endif\nGLOO_ENFORCE_NE(rv, -1, msg)\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `errno.h`: for the `errno` variable\n- `string.h`: for the `strerror()` function\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "84006356-71b7-3f12-a6b2-dfad6f6b8138",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives like `strerror_r()` or `strerror_s()`. Also, consider using higher-level abstractions provided by the C++ Standard Library, which are usually safer and less error-prone.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with its thread-safe counterpart `strerror_r()`:\n\n```cpp\nchar buf[1024];\nGLOO_ENFORCE(rv == 0, strerror_r(errno, buf, sizeof(buf)));\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `errno.h`: for `errno`\n- `string.h`: for `strerror()`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "16f591ef-f299-3a9e-ab98-034d43c84147",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives such as `strerror_r()` in POSIX or `strerror_s()` in Windows. Also, consider using higher-level abstractions provided by the C++ Standard Library, which are usually safer and less error-prone.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with its thread-safe counterpart `strerror_r()`:\n\n```cpp\nchar buf[1024];\nGLOO_ENFORCE(errno == 0, strerror_r(errno, buf, sizeof(buf)));\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `errno.h`: for `errno`\n- `string.h`: for `strerror()`\n- `gloo/Enforce.h`: for `GLOO_ENFORCE()`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "95f6c508-b5ea-3de6-b467-ac6c79ba8c79",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. In the provided code snippet, the `strerror` function is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded context.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `strerror`, you can use `strerror_r` or `strerror_s` which are thread-safe. Also, it is important to validate and sanitize all inputs to these functions to prevent buffer overflows and other related issues.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nchar buf[1024];\nGLOO_ENFORCE(dirp != nullptr, strerror_r(errno, buf, sizeof(buf)));\n```\n\nIn this fix, `strerror_r` is used instead of `strerror`. This function is thread-safe and writes the error message to the provided buffer.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `cstring` for `strerror` function\n- `cerrno` for `errno` variable\n- `gloo` for `GLOO_ENFORCE` macro\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "f60acd9d-4143-3a24-950e-f6b52ede8016",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers are derived from the same array or data structure, and dataflow analysis suggests that they may refer to overlapping memory. Additionally, the source pointer may be null, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues. The classification and verdict both indicate a high-confidence, actionable issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely, whereas `memcpy` is not. Replace the original call with:\n\n```cpp\nmemmove(ptrs_[i], ptrs_[0], bytes_);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap. Always validate that both pointers are non-null before performing the operation to avoid null pointer dereference.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "484d3575-2f87-3dcc-84e1-8c128bb3c7d8",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives such as `strerror_r()` in POSIX or `strerror_s()` in Windows. Always ensure that your code is thread-safe to prevent race conditions.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with `strerror_r()` or `strerror_s()` depending on your platform. Here is an example of how you can do it:\n\n```cpp\nchar buf[1024];\n#if (_POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600) && ! _GNU_SOURCE\n    strerror_r(errno, buf, sizeof(buf));\n#else\n    char *msg = strerror_r(errno, buf, sizeof(buf));\n#endif\nGLOO_ENFORCE_NE(rv, -1, msg)\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `errno.h`: for the `errno` variable\n- `string.h`: for the `strerror()` function\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "91199611-014a-3faf-bf9b-e0f43f77a6a7",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4669bc03-2809-3a3b-96bc-a6a045fb9e3c",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with memcpy. Additionally, there is a risk that the source pointer may be null, as there is no prior check ensuring it is non-null. The destination is not likely to be null, but the overlap and null source risks make this a high-confidence issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(&attr.ai_addr, rp->ai_addr, rp->ai_addrlen);\n```\n\nAdditionally, ensure that `rp->ai_addr` is not null before performing the copy to avoid a null pointer dereference:\n\n```cpp\nif (rp->ai_addr != NULL) {\n    memmove(&attr.ai_addr, rp->ai_addr, rp->ai_addrlen);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c04123ce-49c4-30c1-8a74-1c270ccefdc7",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with functions like memcpy. There are no indications that the source or destination pointers are null, and the source is not a string literal or constant, which would otherwise reduce the risk. No explicit bounds or guards are present to mitigate the risk. Therefore, this is a high-confidence, actionable issue that should be addressed to prevent potential memory corruption or program instability.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely, whereas `memcpy` is not. Replace the original call with:\n\n```cpp\nmemmove(&attr.ai_addr, ifa->ifa_addr, attr.ai_addrlen);\n```\n\nThis change ensures that the memory copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "cbbb9097-eeac-381b-8aca-af1ab01330f7",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The dataflow analysis indicates that the destination and source may refer to overlapping memory, which is not allowed for the standard memory copy function used here. The verdict is supported by the classification and the explicit 'GENUINE' label. There are no guards or evidence that the source or destination are null, and the source and destination are not simple string literals or constant data, which would otherwise reduce the risk. The absence of a length derived from the destination's capacity and the lack of explicit null-termination further support the risk assessment. Developers should address this to prevent undefined behavior, which can lead to security vulnerabilities or program instability.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy function with one that is safe for overlapping regions. In C and C++, use `memmove` instead of `memcpy` for such cases. This ensures that the copy operation is performed correctly even if the regions overlap.\n\n```cpp\nmemmove(&attr.ai_addr, ifa->ifa_addr, attr.ai_addrlen);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "887de324-11b9-3d76-b5ae-8d3cbc594548",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with functions like memcpy. There are no guards or checks to prevent this, and neither the source nor destination is null at the call site, so the main concern is the potential for overlapping memory regions. This type of issue can lead to data corruption or crashes at runtime.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between regions that may overlap, use a function that is safe for overlapping memory, such as `memmove` instead of `memcpy`. Replace the original call with `memmove` to ensure correct behavior even if the source and destination overlap.\n\n```cpp\nmemmove(&attr.ai_addr, ifa->ifa_addr, attr.ai_addrlen);\n```\n\nThis change ensures that the memory copy will work correctly regardless of whether the source and destination regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "f6c4835d-7939-3d47-a95b-0bf2b378d2f2",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives such as `strerror_r()` in POSIX or `strerror_s()` in Windows. Always ensure that your code is thread-safe to prevent race conditions.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with `strerror_r()` or `strerror_s()` depending on your platform. Here is an example of how you can do it:\n\n```cpp\nchar buf[1024];\n#if (_POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600) && ! _GNU_SOURCE\n    strerror_r(errno, buf, sizeof(buf));\n#else\n    char *msg = strerror_r(errno, buf, sizeof(buf));\n#endif\nGLOO_ENFORCE_NE(rv, -1, msg)\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `errno.h`: for the `errno` variable\n- `string.h`: for the `strerror()` function\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "e7ce36cb-52aa-3534-ac0c-f07a093e4fc2",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. Specifically, there is evidence that the source and destination pointers may refer to overlapping memory (an alias assignment was observed), which is not allowed for the memcpy function and can result in unpredictable program behavior. The destination and source pointers are both checked to be non-null before the call, reducing the risk of null pointer dereference, but the overlap risk remains. The count argument is not directly derived from the destination's capacity, and there is no explicit guard or null-termination after the copy. This combination of factors makes the issue actionable and not a likely false positive.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to safely handle overlapping memory. This change ensures that the copy operation is well-defined even if the source and destination regions overlap.\n\n```cpp\nmemmove(out->ptr, in->ptr, opts.elements * opts.elementSize);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ec005ff6-7e92-366d-b865-51282adf062a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions in a memory copy operation. The destination and source pointers may refer to overlapping memory, as indicated by the data flow analysis. Additionally, the source pointer may be null, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues. The classification and verdict both indicate a high-confidence, actionable issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(ptrs_[i], ptrs_[0], bytes_);\n```\n\nAdditionally, ensure that both `ptrs_[i]` and `ptrs_[0]` are valid, non-null pointers before performing the operation to avoid null pointer dereference. For example:\n\n```cpp\nif (ptrs_[i] != nullptr && ptrs_[0] != nullptr) {\n    memmove(ptrs_[i], ptrs_[0], bytes_);\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "70fb2565-7708-3f75-90cc-bd0da2a734fc",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are derived from related data structures, and dataflow analysis suggests that they may refer to overlapping memory. Additionally, the source may be null at this call site, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the function does not ensure that the source and destination are distinct or valid. These factors indicate a real risk of memory corruption or program crashes if the overlap or null pointer dereference occurs.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, validate that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n**Remediation Example:**\n\n```cpp\n// Check for null source and use memmove for possible overlap\nif (inbox_[chunkOffset & 1] != nullptr) {\n    memmove(&ptrs_[0][offset], inbox_[chunkOffset & 1], length * sizeof(T));\n}\n// Optionally, handle the error case if the source is null\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "03e0fab1-b339-3b6d-8a5a-0eb97d3704e8",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the destination and source pointers may refer to overlapping memory areas, which is not allowed for the memcpy function and can result in unpredictable program behavior. Additionally, the analysis could not rule out the possibility that the source pointer may be null, which would also cause undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the verdict confirms this is a high-confidence finding. Developers should ensure that the source and destination do not overlap and are valid before performing the memory copy.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before copying.\n\n```cpp\nif (ptrs_[i] != nullptr && ptrs_[0] != nullptr &&\n    (ptrs_[i] + bytes_ <= ptrs_[0] || ptrs_[0] + bytes_ <= ptrs_[i])) {\n    memcpy(ptrs_[i], ptrs_[0], bytes_);\n} else if (ptrs_[i] != nullptr && ptrs_[0] != nullptr) {\n    // Safe fallback for overlapping regions\n    memmove(ptrs_[i], ptrs_[0], bytes_);\n}\n```\n\nThis code first checks that both pointers are not null and that the memory regions do not overlap before using `memcpy`. If overlap is detected, it uses `memmove` as a safe alternative.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "9501b3ed-5fd6-38ec-bffc-c4d9a4b1febd",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The dataflow analysis suggests that the source and destination may refer to overlapping memory, which is not allowed for memcpy and can result in unpredictable program behavior. Additionally, there is no evidence of a guard or check to prevent this overlap, and the source pointer may also be null, further increasing the risk. The classification and verdict both indicate a high-confidence issue that should be addressed.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping memory safely. This change ensures that the copy operation will not result in unpredictable behavior if the source and destination regions overlap.\n\n```cpp\nmemmove(static_cast<char*>(out->ptr) + myRank * chunkSize, static_cast<char*>(in->ptr) + myRank * chunkSize, chunkSize);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "81af8a7a-b52d-311d-9e2a-b2c11d9e9a9d",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers may refer to overlapping memory, as indicated by the dataflow analysis. In C and C++, using memcpy with overlapping memory regions is undefined behavior and can lead to unpredictable results or security vulnerabilities. There are no explicit checks or guards in the code to prevent this overlap, and the function verdict confirms this as a genuine issue. The source and destination are both non-null, so null pointer dereference is not a concern here. The main risk is the potential for memory corruption or data loss due to undefined behavior.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to safely handle overlapping memory. The function call remains the same, but the function name changes:\n\n```cpp\nmemmove(static_cast<char*>(out->ptr) + offset, in->ptr, in->size);\n```\n\nThis change ensures that the memory copy operation is safe even if the source and destination regions overlap, eliminating the risk of undefined behavior.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "381bd970-92bd-323f-a7e7-271694942b0e",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using insecure and non-thread-safe C library functions. Instead, use their secure alternatives that are provided in the C++ Standard Library. For instance, instead of `strerror()`, use `strerror_s()` or `strerror_r()`, which are thread-safe.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with `strerror_s()` or `strerror_r()`. Here is how you can do it:\n\n```cpp\nchar buf[256];\nstrerror_s(buf, sizeof buf, optval);\nGLOO_ERROR_MSG(\"connect \", peer_.str(), \": \", buf);\n```\n\nor\n\n```cpp\nchar buf[256];\nstrerror_r(optval, buf, sizeof buf);\nGLOO_ERROR_MSG(\"connect \", peer_.str(), \": \", buf);\n```\n\n## Library Dependencies\n\nThe code snippet seems to be using the Gloo library for collective communications. Therefore, the Gloo library is required for the code to execute properly.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "5b00e094-edfe-357c-b47f-652de84cbe24",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions in the code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. In the case of `strerror()`, a safer alternative is `strerror_r()`, which is thread-safe.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with `strerror_r()` in the code snippet:\n\n```cpp\nchar buf[1024];\nstrerror_r(errno, buf, sizeof(buf));\nsignalException(GLOO_ERROR_MSG(\"accept: \", buf))\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<cstring>`: for `strerror_r()`\n- `<cerrno>`: for `errno`\n- `<gloo/error.h>`: for `GLOO_ERROR_MSG()`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "8ac08341-5db8-35f2-8733-b389f4b676e8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are considered insecure because they do not perform bounds checking and other necessary validations, which can lead to buffer overflow attacks, format string vulnerabilities, and other security issues. In the provided code snippet, the `strerror` function is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure alternatives to these insecure C library functions. For instance, instead of using `strerror`, you can use `strerror_r` or `strerror_s` which are thread-safe. Also, consider using C++ standard library functions and classes that provide the necessary bounds checking and validation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nchar buf[1024];\nif (strerror_r(errno, buf, sizeof(buf)) != 0) {\n    buf[0] = '\\0';  // Fallback\n}\nGLOO_ERROR_MSG(\"Read error \", peer_.str(), \": \", buf);\n```\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `<cstring>`: for `strerror` function\n- `<cerrno>`: for `errno`\n\n## OWASP and CWE Links\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that these links are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "b4bd9cde-a788-3ebf-92a7-4a9d2e82495d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `strerror` is used which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror`. Instead, use thread-safe alternatives like `strerror_r` (in POSIX) or `strerror_s` (in Windows). Also, consider using higher-level abstractions provided by the C++ Standard Library, which are usually safer and less error-prone.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror` function with its thread-safe counterpart `strerror_r`:\n\n```cpp\nchar buf[1024];\nstrerror_r(errno, buf, sizeof(buf));\nGLOO_ERROR_MSG(\"writev \", peer_.str(), \": \", buf);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstring` for `strerror` or `strerror_r`\n- `cerrno` for `errno`\n- `gloo` for `GLOO_ERROR_MSG`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "6b665f15-2f96-3e9c-9ae1-251cbd1bc4a3",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `strerror()` is used which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives like `strerror_r()` in POSIX or `strerror_s()` in Windows. Also, consider using higher-level abstractions provided by the C++ Standard Library, which are usually safer and less error-prone.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with its thread-safe counterpart `strerror_r()`:\n\n```cpp\nchar buf[1024];\nstrerror_r(errno, buf, sizeof(buf));\nsignalAndThrowException(GLOO_ERROR_MSG(\"connect: \", buf));\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstring` for `strerror()`\n- `cerrno` for `errno`\n- `Gloo` for `GLOO_ERROR_MSG()`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "fd75822b-078f-325a-bede-4725e9d9e9d8",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives like `strerror_r()` in POSIX or `strerror_s()` in Windows. Also, consider using higher-level abstractions provided by the C++ Standard Library or other libraries that are designed with safety in mind.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with its thread-safe counterpart `strerror_r()`:\n\n```cpp\nchar buf[1024];\nstrerror_r(errno, buf, sizeof(buf));\nsignalAndThrowException(GLOO_ERROR_MSG(\"setsockopt: \", buf));\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstring` for `strerror()`\n- `cerrno` for `errno`\n- `Gloo` for `GLOO_ERROR_MSG()`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "7c6b43d4-d76c-367c-b952-eef692ba8dd3",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives like `strerror_r()` in POSIX or `strerror_s()` in Windows. Also, consider using higher-level abstractions provided by the C++ Standard Library, which are usually safer and less error-prone.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with its thread-safe counterpart `strerror_r()`:\n\n```cpp\nchar buf[1024];\nstrerror_r(errno, buf, sizeof(buf));\nsignalAndThrowException(GLOO_ERROR_MSG(\"socket: \", buf));\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstring` for `strerror()`\n- `cerrno` for `errno`\n- `Gloo` for `GLOO_ERROR_MSG()`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "1335673f-b0fc-3092-b762-9d794e45e49a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives like `strerror_r()` in POSIX or `strerror_s()` in Windows. Also, consider using higher-level abstractions provided by the C++ Standard Library, which are usually safer and less error-prone.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with its thread-safe counterpart `strerror_r()`:\n\n```cpp\nchar buf[1024];\nif (strerror_r(errno, buf, sizeof(buf)) != 0) {\n    // handle error\n}\nsignalAndThrowException(GLOO_ERROR_MSG(\"listen: \", buf))\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstring` for `strerror()`\n- `cerrno` for `errno`\n- `Gloo` for `GLOO_ERROR_MSG()`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "c101b4f5-a1bc-3fd9-b848-865b5539713d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure alternatives to these insecure C library functions. In the case of `strerror()`, a thread-safe alternative `strerror_r()` can be used.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with `strerror_r()` in the provided code snippet:\n\n```cpp\nchar buf[1024];\nstrerror_r(errno, buf, sizeof(buf));\nsignalAndThrowException(GLOO_ERROR_MSG(\"bind: \", buf))\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `errno.h`: for `errno`\n- `string.h`: for `strerror()`\n- `gloo`: for `GLOO_ERROR_MSG()`\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "6274f92c-0f62-3b0b-b06f-38daa190c1ec",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives like `strerror_r()` in POSIX or `strerror_s()` in Windows. Also, consider using higher-level abstractions provided by the C++ Standard Library or other libraries that are designed with safety in mind.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with its thread-safe counterpart `strerror_r()`:\n\n```cpp\nchar buf[1024];\nstrerror_r(errno, buf, sizeof(buf));\nsignalAndThrowException(GLOO_ERROR_MSG(\"setsockopt: \", buf));\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstring` for `strerror()`\n- `cerrno` for `errno`\n- `Gloo` for `GLOO_ERROR_MSG()`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "01432ad5-0c92-36cc-90c5-ed6faab06a4f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives like `strerror_r()` in POSIX or `strerror_s()` in Windows. Also, consider using higher-level abstractions provided by the C++ Standard Library, which are usually safer and less error-prone.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with its thread-safe counterpart `strerror_r()`:\n\n```cpp\nchar buf[1024];\nstrerror_r(errno, buf, sizeof(buf));\nsignalAndThrowException(GLOO_ERROR_MSG(\"socket: \", buf));\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstring` for `strerror()`\n- `cerrno` for `errno`\n- `Gloo` for `GLOO_ERROR_MSG()`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "a48a4caf-3da2-3444-8d76-5adf1ce8b2b5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" vulnerability refers to the use of weak or non-cryptographic random number generators in the code. This can lead to predictability in the generated numbers, which can be exploited by attackers to predict the behavior of the program, leading to security vulnerabilities.\n\nWeak or non-cryptographic random number generators do not provide a sufficient level of randomness and can produce predictable outcomes. They are not suitable for generating cryptographic keys or other sensitive data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator. In C++, you can use the `<random>` library, which provides a variety of random number generators. For cryptographic purposes, consider using a library specifically designed for cryptography, such as OpenSSL.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use the `<random>` library to generate random numbers in C++:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_int_distribution` is a random number distribution that produces integers according to a uniform discrete distribution.\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "75da38c9-84f3-37a8-aab4-e52b331d73cb",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using unsafe C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `atoi()`, you can use `std::stoi()` which throws an exception if the conversion fails or if the converted value is out of range.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\n#include <cstdlib>\n#include <string>\n\n// ...\n\ntry {\n    size = std::stoi(getenv(\"SIZE\"));\n} catch (const std::invalid_argument& ia) {\n    // Handle the exception\n} catch (const std::out_of_range& oor) {\n    // Handle the exception\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstdlib` for `getenv()`\n- `string` for `std::stoi()`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n\nPlease note that the links are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189",
                  "75da38c9-84f3-37a8-aab4-e52b331d73cb"
                ]
              }
            },
            {
              "id": "93f0f67f-701c-3b4d-8706-facd802bdbcb",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform bounds checking or handle errors more gracefully. In this case, consider using `strtol()` or `sscanf()` instead of `atoi()`. Always validate and sanitize input data.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n#include <climits>\n#include <cerrno>\n\nconst char* rankStr = getenv(\"RANK\");\nif(rankStr == NULL) {\n    // handle error\n}\n\nchar* end;\nlong rank = strtol(rankStr, &end, 10);\nif (end == rankStr || *end != '\\0' || errno == ERANGE || rank > INT_MAX || rank < INT_MIN) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\n- cstdlib\n- climits\n- cerrno\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)"
              },
              "properties": {
                "tags": [
                  "DS154189",
                  "93f0f67f-701c-3b4d-8706-facd802bdbcb"
                ]
              }
            },
            {
              "id": "89aaf481-27f6-3dc8-b114-e23c395b5191",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using unsafe C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `atoi()`, you can use `std::stoi()` which throws an exception if the conversion fails or if the converted value is out of range.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\n#include <cstdlib>\n#include <string>\n\n// ...\n\ntry {\n    size = std::stoi(getenv(\"SIZE\"));\n} catch (const std::invalid_argument& ia) {\n    // Handle the exception\n} catch (const std::out_of_range& oor) {\n    // Handle the exception\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstdlib` for `getenv()`\n- `string` for `std::stoi()`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n\nPlease note that the links are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189",
                  "89aaf481-27f6-3dc8-b114-e23c395b5191"
                ]
              }
            },
            {
              "id": "36a58001-7324-3017-ab93-278d1325f44d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform bounds checking or handle errors more gracefully. In this case, consider using `strtol()` or `sscanf()` instead of `atoi()`. Always validate and sanitize input data.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n#include <climits>\n#include <cerrno>\n\nconst char* rankStr = getenv(\"RANK\");\nif(rankStr == NULL) {\n    // handle error\n}\n\nchar* end;\nlong rank = strtol(rankStr, &end, 10);\nif (end == rankStr || *end != '\\0' || errno == ERANGE || rank > INT_MAX || rank < INT_MIN) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\n- cstdlib\n- climits\n- cerrno\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)"
              },
              "properties": {
                "tags": [
                  "DS154189",
                  "36a58001-7324-3017-ab93-278d1325f44d"
                ]
              }
            },
            {
              "id": "59e42db4-2d9a-39e5-beac-a75a9295cefb",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, and other security issues. In the provided code snippet, the function `getenv()` is used, which can lead to security vulnerabilities. This function returns a pointer to the value in the environment, or NULL if there is no match. The returned string should not be modified by the program, but it can be overwritten by a subsequent call to `getenv()`, `setenv()`, or `unsetenv()`.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. In this case, consider using a safer method to retrieve environment variables.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // for std::getenv\n\nconst char* prefix = std::getenv(\"PREFIX\");\nif (!prefix) {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\n- cstdlib\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "7bd8efbd-de84-36b5-a623-5193aefabbc6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nProduction Code Debugging Vulnerability in C++ refers to the situation where debugging code or debugging commands are inadvertently left in the production code. This can lead to a variety of security issues, including unauthorized access, information disclosure, and even remote code execution. Debugging code often contains sensitive information or functionality that should not be exposed in a production environment.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always remove debugging code or commands before deploying to production.\n2. Use preprocessor directives to ensure debugging code is not included in the production build.\n3. Regularly review and audit your code to ensure no debugging code has been left in.\n4. Use automated tools to check for common debugging commands or code snippets.\n\n## Source Code Fix Recommendation\n\nIf you have a piece of code like this:\n\n```cpp\n#define DEBUG\n\n#ifdef DEBUG\n    cout << \"Debugging information: \" << sensitive_info << endl;\n#endif\n\n// Production code here\n```\n\nYou should remove or comment out the `#define DEBUG` line before deploying to production:\n\n```cpp\n//#define DEBUG\n\n#ifdef DEBUG\n    cout << \"Debugging information: \" << sensitive_info << endl;\n#endif\n\n// Production code here\n```\n\n## Library Dependencies\n\nThe code example provided does not require any additional library dependencies.\n\n## References\n\n- [OWASP Code Review Guide](https://owasp.org/www-project-code-review-guide/)\n- [CWE-489: Leftover Debug Code](https://cwe.mitre.org/data/definitions/489.html)"
              },
              "properties": {
                "tags": [
                  "DS162092"
                ]
              }
            },
            {
              "id": "99194be6-eb75-3ea9-b61a-9b771a695850",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Debug Code in Production Vulnerability\" refers to the situation where debug code is accidentally left in the production environment. This can lead to a variety of security issues, including information disclosure, unauthorized access, and even remote code execution. In C++, this can occur when debug statements that print sensitive information to the console or log files are not removed before the code is deployed to production.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, follow these general guidelines:\n\n- Always remove or disable debug code before deploying to production.\n- Use preprocessor directives to ensure debug code is not included in production builds.\n- Regularly review your codebase for leftover debug code.\n- Use automated tools to scan for potential debug code in production.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use preprocessor directives to ensure debug code is not included in production builds in C++:\n\n```cpp\n// Debug code\n#ifdef DEBUG\n    std::cout << \"Debug information: \" << sensitive_info << std::endl;\n#endif\n```\n\nIn this example, the debug code will only be included if the DEBUG preprocessor symbol is defined. This symbol should be defined in your development environment, but not in your production environment.\n\n## Library Dependencies\n\nThe code example does not require any additional library dependencies.\n\n## References\n\n- [CWE-489: Leftover Debug Code](https://cwe.mitre.org/data/definitions/489.html)"
              },
              "properties": {
                "tags": [
                  "DS162092",
                  "99194be6-eb75-3ea9-b61a-9b771a695850"
                ]
              }
            },
            {
              "id": "68a5eda2-c9eb-3721-a3e3-f987a0ec0f59",
              "help": {
                "text": "",
                "markdown": "## Description\n\nProduction Code Debugging Vulnerability in C++ refers to the situation where debugging code or debugging commands are inadvertently left in the production code. This can lead to a variety of security issues, including unauthorized access, information disclosure, and even remote code execution. Debugging code often contains sensitive information or functionality that should not be exposed in a production environment.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always remove debugging code or commands before deploying to production.\n2. Use preprocessor directives to ensure debugging code is not included in the production build.\n3. Regularly review and audit your code to ensure no debugging code has been left in.\n4. Use automated tools to check for common debugging commands or code snippets.\n\n## Source Code Fix Recommendation\n\nIf you have a piece of code like this:\n\n```cpp\n#define DEBUG\n\n#ifdef DEBUG\n    cout << \"Debugging information: \" << sensitive_info << endl;\n#endif\n\n// Production code here\n```\n\nYou should remove or comment out the `#define DEBUG` line before deploying to production:\n\n```cpp\n//#define DEBUG\n\n#ifdef DEBUG\n    cout << \"Debugging information: \" << sensitive_info << endl;\n#endif\n\n// Production code here\n```\n\n## Library Dependencies\n\nThe code example provided does not require any additional library dependencies.\n\n## References\n\n- [OWASP Code Review Guide](https://owasp.org/www-project-code-review-guide/)\n- [CWE-489: Leftover Debug Code](https://cwe.mitre.org/data/definitions/489.html)"
              },
              "properties": {
                "tags": [
                  "DS162092",
                  "68a5eda2-c9eb-3721-a3e3-f987a0ec0f59"
                ]
              }
            },
            {
              "id": "46221b18-05e7-36d8-a988-790924317714",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `getenv` function is used, which can lead to security vulnerabilities. The `getenv` function returns a pointer to a string that is associated with the matched environment variable name passed as input. If the specified environment variable is not found, the function returns a null pointer. This can lead to null pointer dereferencing issues if not properly checked.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. Always validate and sanitize input from untrusted sources. Be aware of the potential security implications of using certain C library functions.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // for getenv\n#include <string>  // for std::string\n\nstd::string rank;\nchar* tmp = std::getenv(\"RANK\");\nif (tmp == nullptr) {\n    // handle error, e.g., set rank to a default value\n    rank = \"default\";\n} else {\n    rank = tmp;\n}\n```\n\n## Library Dependencies\n\n- `<cstdlib>`: This header defines several general purpose functions, including dynamic memory management, random number generation, communication with the environment, integer arithmetics, searching, sorting and converting.\n\n- `<string>`: This header introduces string types, character traits and a set of converting functions.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-628: Function Call with Incorrectly Specified Arguments](https://cwe.mitre.org/data/definitions/628.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "c3bb4fbe-31cf-35ff-84ca-9d0c2a14884e",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `getenv` function is used, which can lead to security vulnerabilities. The `getenv` function returns a pointer to a string that is associated with the matched environment variable name. If the specified environment variable is not found, the function returns a null pointer. This can lead to null pointer dereferencing issues if not properly checked.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. In this case, consider using the `std::getenv` function from the C++ Standard Library, which is a safer alternative to the C `getenv` function. Always check the returned pointer before using it.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\n#include <cstdlib>\n\nconst char* size = std::getenv(\"SIZE\");\nif (size != nullptr) {\n    // Use 'size' variable\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- cstdlib\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-628: Function Call with Incorrectly Specified Arguments](https://cwe.mitre.org/data/definitions/628.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "007912d5-8174-3efd-9e02-d0e26291636d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the `getenv` function is used, which can lead to security vulnerabilities if not properly handled. The `getenv` function returns a pointer to a string that is associated with the matched environment variable name. If the specified environment variable is not found, the function returns a null pointer. This can lead to null pointer dereferencing if not properly checked.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to avoid using unsafe C functions where possible and instead use safer alternatives provided by the C++ standard library. If the use of such functions is unavoidable, ensure that proper error checking and handling is in place.\n\n## Source Code Fix Recommendation\n\nIn this case, the code is checking if the environment variables \"PREFIX\", \"SIZE\", and \"RANK\" are set. If any of them is not set, it will return a null pointer which can lead to null pointer dereferencing. To fix this, you can add proper error handling after each `getenv` call:\n\n```cpp\nchar* prefix = getenv(\"PREFIX\");\nchar* size = getenv(\"SIZE\");\nchar* rank = getenv(\"RANK\");\n\nif (prefix == nullptr || size == nullptr || rank == nullptr) {\n    // Handle error here, e.g., exit the program or throw an exception\n    std::cerr << \"Required environment variables are not set\" << std::endl;\n    exit(1);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the `cstdlib` library for the `getenv` function and the `iostream` library for error output.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-628: Function Call with Incorrectly Specified Arguments](https://cwe.mitre.org/data/definitions/628.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "509bee2c-39d6-3d57-a505-a0caaae0f2a9",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the source and destination pointers may refer to overlapping memory areas, which is not allowed for the standard memory copy function and can result in unpredictable program behavior or data corruption. Additionally, the analysis could not rule out the possibility that the source pointer may be null, which would also lead to undefined behavior if dereferenced. There are no explicit checks or guards in the code to prevent these issues, and the verdict confirms this is a high-confidence finding.\n\n## In Context Remediation 0\nTo prevent undefined behavior when copying memory regions that may overlap, replace the standard memory copy function with a function that safely handles overlapping regions. In C and C++, use `memmove` instead of `memcpy` for such cases. `memmove` is designed to correctly handle overlapping source and destination buffers.\n\n**Remediation Example:**\n\n```cpp\n// Replace this:\nmemcpy(ptrs_[i], ptrs_[0], bytes_);\n\n// With this:\nmemmove(ptrs_[i], ptrs_[0], bytes_);\n```\n\nThis change ensures that even if the source and destination memory regions overlap, the copy will be performed safely and predictably.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## In Context Remediation 1\nBefore performing the memory copy, add explicit checks to ensure that the source pointer is not null. This helps prevent undefined behavior due to null pointer dereference.\n\n**Remediation Example:**\n\n```cpp\nif (ptrs_[0] != nullptr) {\n    memmove(ptrs_[i], ptrs_[0], bytes_);\n}\n// Optionally, handle the error case if ptrs_[0] is null\n```\n\nThis check ensures that the source pointer is valid before attempting the memory operation.\n\n## References\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "51a6f854-4eda-3126-a242-2ca7da87fde6",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are derived from the same base array, and dataflow analysis suggests that the regions may overlap. Additionally, the source pointer may be null, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the count argument is not directly tied to the capacity of the destination buffer. These factors indicate a real risk of memory corruption or program crashes if the overlap or null pointer scenarios occur.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(&ptrs_[0][bufferOffset], &ptrs_[0][distMap.offset], distMap.itemCount * sizeof(T));\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the operation. For example:\n\n```cpp\nif (&ptrs_[0][bufferOffset] != nullptr && &ptrs_[0][distMap.offset] != nullptr) {\n    memmove(&ptrs_[0][bufferOffset], &ptrs_[0][distMap.offset], distMap.itemCount * sizeof(T));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "2111233a-9672-32d6-98a3-3749cb802ae8",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions. The analysis detected that the destination and source may overlap based on data flow, which can cause undefined behavior when using memory copy functions like memcpy. Additionally, the source may be null, which further increases the risk of runtime errors. There are no explicit guards or checks to prevent these issues, and the function call is not protected by any bounds or null checks. The verdict is marked as genuine, confirming the high confidence in this being a real issue.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to safely handle overlapping memory areas.\n\n```cpp\nmemmove(&ptrs_[0][bufferOffset], &recvBufDist_[distMap.offset], distMap.itemCount * sizeof(T));\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the memory operation. For example:\n\n```cpp\nif (&ptrs_[0][bufferOffset] != nullptr && &recvBufDist_[distMap.offset] != nullptr) {\n    memmove(&ptrs_[0][bufferOffset], &recvBufDist_[distMap.offset], distMap.itemCount * sizeof(T));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "36c016b9-1171-35d4-bf56-7839796674ca",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis determined that the source and destination pointers may refer to overlapping memory areas, which is not allowed for the memcpy function and can result in unpredictable program behavior. Additionally, the analysis could not rule out the possibility that the source pointer may be null, which would also cause undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the verdict for this call site is marked as genuine. The risk is further increased because the memory regions are determined dynamically, and there is no evidence that the length argument is derived from the actual capacity of the destination buffer.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. The `memmove` function is designed to handle overlapping memory safely. Replace the original call with:\n\n```cpp\nmemmove(ptrs_[i], ptrs_[0], bytes_);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap. Always verify that both pointers are valid and that the number of bytes does not exceed the allocated size of the destination buffer.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "8ca03b24-f237-3672-a594-455472c7ed5e",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using unsafe C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `atoi()`, you can use `std::stoi()` which throws an exception if the conversion fails or if the converted value is out of range.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\n#include <cstdlib>\n#include <string>\n\n// ...\n\ntry {\n    size = std::stoi(getenv(\"SIZE\"));\n} catch (const std::invalid_argument& ia) {\n    // Handle the exception\n} catch (const std::out_of_range& oor) {\n    // Handle the exception\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstdlib` for `getenv()`\n- `string` for `std::stoi()`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n\nPlease note that the links are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189",
                  "8ca03b24-f237-3672-a594-455472c7ed5e"
                ]
              }
            },
            {
              "id": "92ee8625-3352-3019-b6f8-fd6898014879",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using unsafe C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `atoi()`, you can use `std::stoi()` which throws an exception if the conversion fails or if the converted value is out of range.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\n#include <cstdlib>\n#include <string>\n\n// ...\n\ntry {\n    size = std::stoi(getenv(\"SIZE\"));\n} catch (const std::invalid_argument& ia) {\n    // Handle the exception\n} catch (const std::out_of_range& oor) {\n    // Handle the exception\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstdlib` for `getenv()`\n- `string` for `std::stoi()`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n\nPlease note that the links are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189",
                  "92ee8625-3352-3019-b6f8-fd6898014879"
                ]
              }
            },
            {
              "id": "6def11ef-3ea8-34d7-af75-d123cb4643b9",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform bounds checking or handle errors more gracefully. In this case, consider using `strtol()` or `sscanf()` instead of `atoi()`. Always validate and sanitize input data.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n#include <climits>\n#include <cerrno>\n\nconst char* rankStr = getenv(\"RANK\");\nif(rankStr == NULL) {\n    // handle error\n}\n\nchar* end;\nlong rank = strtol(rankStr, &end, 10);\nif (end == rankStr || *end != '\\0' || errno == ERANGE || rank > INT_MAX || rank < INT_MIN) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\n- cstdlib\n- climits\n- cerrno\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)"
              },
              "properties": {
                "tags": [
                  "DS154189",
                  "6def11ef-3ea8-34d7-af75-d123cb4643b9"
                ]
              }
            },
            {
              "id": "947631b7-c4b4-39e7-a020-e4ddeb1b5ac2",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform bounds checking or handle errors more gracefully. In this case, consider using `strtol()` or `sscanf()` instead of `atoi()`. Always validate and sanitize input data.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n#include <climits>\n#include <cerrno>\n\nconst char* rankStr = getenv(\"RANK\");\nif(rankStr == NULL) {\n    // handle error\n}\n\nchar* end;\nlong rank = strtol(rankStr, &end, 10);\nif (end == rankStr || *end != '\\0' || errno == ERANGE || rank > INT_MAX || rank < INT_MIN) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\n- cstdlib\n- climits\n- cerrno\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)"
              },
              "properties": {
                "tags": [
                  "DS154189",
                  "947631b7-c4b4-39e7-a020-e4ddeb1b5ac2"
                ]
              }
            },
            {
              "id": "1e6f321b-8782-32f7-8087-2644ebe3451a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, and other security issues. In the provided code snippet, the function `getenv()` is used, which can lead to security vulnerabilities. This function returns a pointer to the value in the environment, or NULL if there is no match. The returned string should not be modified by the program, but it can be overwritten by a subsequent call to `getenv()`, `setenv()`, or `unsetenv()`.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. In this case, consider using a safer method to retrieve environment variables.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // for std::getenv\n\nconst char* prefix = std::getenv(\"PREFIX\");\nif (!prefix) {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\n- cstdlib\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "bc0923b1-20f9-3ac6-85fb-25f7a319f52f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nProduction Code Debugging Vulnerability in C++ refers to the situation where debugging code or debugging commands are inadvertently left in the production code. This can lead to a variety of security issues, including unauthorized access, information disclosure, and even remote code execution. Debugging code often contains sensitive information or functionality that should not be exposed in a production environment.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always remove debugging code or commands before deploying to production.\n2. Use preprocessor directives to ensure debugging code is not included in the production build.\n3. Regularly review and audit your code to ensure no debugging code has been left in.\n4. Use automated tools to check for common debugging commands or code snippets.\n\n## Source Code Fix Recommendation\n\nIf you have a piece of code like this:\n\n```cpp\n#define DEBUG\n\n#ifdef DEBUG\n    cout << \"Debugging information: \" << sensitive_info << endl;\n#endif\n\n// Production code here\n```\n\nYou should remove or comment out the `#define DEBUG` line before deploying to production:\n\n```cpp\n//#define DEBUG\n\n#ifdef DEBUG\n    cout << \"Debugging information: \" << sensitive_info << endl;\n#endif\n\n// Production code here\n```\n\n## Library Dependencies\n\nThe code example provided does not require any additional library dependencies.\n\n## References\n\n- [OWASP Code Review Guide](https://owasp.org/www-project-code-review-guide/)\n- [CWE-489: Leftover Debug Code](https://cwe.mitre.org/data/definitions/489.html)"
              },
              "properties": {
                "tags": [
                  "DS162092"
                ]
              }
            },
            {
              "id": "6043023d-c22f-34ea-9ea9-8c0ae6a020df",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Debug Code in Production Vulnerability\" refers to the situation where debug code is accidentally left in the production environment. This can lead to a variety of security issues, including information disclosure, unauthorized access, and even remote code execution. In C++, this can occur when debug statements that print sensitive information to the console or log files are not removed before the code is deployed to production.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, follow these general guidelines:\n\n- Always remove or disable debug code before deploying to production.\n- Use preprocessor directives to ensure debug code is not included in production builds.\n- Regularly review your codebase for leftover debug code.\n- Use automated tools to scan for potential debug code in production.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use preprocessor directives to ensure debug code is not included in production builds in C++:\n\n```cpp\n// Debug code\n#ifdef DEBUG\n    std::cout << \"Debug information: \" << sensitive_info << std::endl;\n#endif\n```\n\nIn this example, the debug code will only be included if the DEBUG preprocessor symbol is defined. This symbol should be defined in your development environment, but not in your production environment.\n\n## Library Dependencies\n\nThe code example does not require any additional library dependencies.\n\n## References\n\n- [CWE-489: Leftover Debug Code](https://cwe.mitre.org/data/definitions/489.html)"
              },
              "properties": {
                "tags": [
                  "DS162092",
                  "6043023d-c22f-34ea-9ea9-8c0ae6a020df"
                ]
              }
            },
            {
              "id": "7cd7373f-cfad-31cf-aac3-9c25893b0219",
              "help": {
                "text": "",
                "markdown": "## Description\n\nProduction Code Debugging Vulnerability in C++ refers to the situation where debugging code or debugging commands are inadvertently left in the production code. This can lead to a variety of security issues, including unauthorized access, information disclosure, and even remote code execution. Debugging code often contains sensitive information or functionality that should not be exposed in a production environment.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always remove debugging code or commands before deploying to production.\n2. Use preprocessor directives to ensure debugging code is not included in the production build.\n3. Regularly review and audit your code to ensure no debugging code has been left in.\n4. Use automated tools to check for common debugging commands or code snippets.\n\n## Source Code Fix Recommendation\n\nIf you have a piece of code like this:\n\n```cpp\n#define DEBUG\n\n#ifdef DEBUG\n    cout << \"Debugging information: \" << sensitive_info << endl;\n#endif\n\n// Production code here\n```\n\nYou should remove or comment out the `#define DEBUG` line before deploying to production:\n\n```cpp\n//#define DEBUG\n\n#ifdef DEBUG\n    cout << \"Debugging information: \" << sensitive_info << endl;\n#endif\n\n// Production code here\n```\n\n## Library Dependencies\n\nThe code example provided does not require any additional library dependencies.\n\n## References\n\n- [OWASP Code Review Guide](https://owasp.org/www-project-code-review-guide/)\n- [CWE-489: Leftover Debug Code](https://cwe.mitre.org/data/definitions/489.html)"
              },
              "properties": {
                "tags": [
                  "DS162092",
                  "7cd7373f-cfad-31cf-aac3-9c25893b0219"
                ]
              }
            },
            {
              "id": "91918fef-3426-340b-bf88-57441c04ff81",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `getenv` function is used, which can lead to security vulnerabilities. The `getenv` function returns a pointer to a string that is associated with the matched environment variable name passed as input. If the specified environment variable is not found, the function returns a null pointer. This can lead to null pointer dereferencing issues if not properly checked.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. Always validate and sanitize input from untrusted sources. Be aware of the potential security implications of using certain C library functions.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // for getenv\n#include <string>  // for std::string\n\nstd::string rank;\nchar* tmp = std::getenv(\"RANK\");\nif (tmp == nullptr) {\n    // handle error, e.g., set rank to a default value\n    rank = \"default\";\n} else {\n    rank = tmp;\n}\n```\n\n## Library Dependencies\n\n- `<cstdlib>`: This header defines several general purpose functions, including dynamic memory management, random number generation, communication with the environment, integer arithmetics, searching, sorting and converting.\n\n- `<string>`: This header introduces string types, character traits and a set of converting functions.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-628: Function Call with Incorrectly Specified Arguments](https://cwe.mitre.org/data/definitions/628.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4ca99c26-89df-3f26-a174-d7308feae32d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `getenv` function is used, which can lead to security vulnerabilities. The `getenv` function returns a pointer to a string that is associated with the matched environment variable name. If the specified environment variable is not found, the function returns a null pointer. This can lead to null pointer dereferencing issues if not properly checked.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. In this case, consider using the `std::getenv` function from the C++ Standard Library, which is a safer alternative to the C `getenv` function. Always check the returned pointer before using it.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\n#include <cstdlib>\n\nconst char* size = std::getenv(\"SIZE\");\nif (size != nullptr) {\n    // Use 'size' variable\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- cstdlib\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-628: Function Call with Incorrectly Specified Arguments](https://cwe.mitre.org/data/definitions/628.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "e53c23e8-a230-36ed-8366-572a7ef4f6fe",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the `getenv` function is used, which can lead to security vulnerabilities if not properly handled. The `getenv` function returns a pointer to a string that is associated with the matched environment variable name. If the specified environment variable is not found, the function returns a null pointer. This can lead to null pointer dereferencing if not properly checked.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to avoid using unsafe C functions where possible and instead use safer alternatives provided by the C++ standard library. If the use of such functions is unavoidable, ensure that proper error checking and handling is in place.\n\n## Source Code Fix Recommendation\n\nIn this case, the code is checking if the environment variables \"PREFIX\", \"SIZE\", and \"RANK\" are set. If any of them is not set, it will return a null pointer which can lead to null pointer dereferencing. To fix this, you can add proper error handling after each `getenv` call:\n\n```cpp\nchar* prefix = getenv(\"PREFIX\");\nchar* size = getenv(\"SIZE\");\nchar* rank = getenv(\"RANK\");\n\nif (prefix == nullptr || size == nullptr || rank == nullptr) {\n    // Handle error here, e.g., exit the program or throw an exception\n    std::cerr << \"Required environment variables are not set\" << std::endl;\n    exit(1);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the `cstdlib` library for the `getenv` function and the `iostream` library for error output.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-628: Function Call with Incorrectly Specified Arguments](https://cwe.mitre.org/data/definitions/628.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "8481cffe-8839-30f4-9d07-78e4eb668a6e",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers are derived from the same array or data structure, and dataflow analysis suggests that they may refer to overlapping memory. Additionally, the source pointer may be null at runtime, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues. The classification and verdict both indicate a high-confidence, actionable problem that could result in memory corruption or program crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely, whereas `memcpy` is not. Replace the original call with:\n\n```cpp\nmemmove(ptrs_[i], ptrs_[0], bytes_);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap. Always validate that both source and destination pointers are not null before performing the operation to avoid null pointer dereference.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "bef8a2eb-9ef8-3769-890a-053e9899b797",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are derived from potentially overlapping buffers, as indicated by the dataflow analysis. Additionally, the source pointer may be null, which further increases the risk of undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the count argument is not directly tied to the capacity of the destination buffer. These factors together indicate a real risk of memory corruption or program crashes if the overlap or null pointer conditions occur at runtime.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping memory safely. For example, replace the original call with:\n\n```cpp\nmemmove(&ptrs_[0][sendOffsets_[i]], &recvBuf_[bufferOffset], sendCounts_[i] * sizeof(T));\n```\n\nAdditionally, validate that the source pointer is not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (&recvBuf_[bufferOffset] != nullptr) {\n    memmove(&ptrs_[0][sendOffsets_[i]], &recvBuf_[bufferOffset], sendCounts_[i] * sizeof(T));\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [NIST Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a45cf520-4225-335a-9341-f966332789e1",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are derived from related data structures, and dataflow analysis suggests that the destination may overlap with the source. Additionally, the source pointer may be null at runtime, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the function does not ensure that the memory regions are distinct. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(&ptrs_[0][offset], &recvBuf_[bufferOffset], totalItemsToSend * sizeof(T));\n```\n\nAdditionally, ensure that both source and destination pointers are valid and not null before performing the operation. For example:\n\n```cpp\nif (&ptrs_[0][offset] != nullptr && &recvBuf_[bufferOffset] != nullptr) {\n    memmove(&ptrs_[0][offset], &recvBuf_[bufferOffset], totalItemsToSend * sizeof(T));\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "74c2f3ea-7d4a-3da8-805b-44932e22bc56",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers are derived from the same array or data structure, and dataflow analysis indicates that they may refer to overlapping memory. The use of a standard memory copy function in such a scenario can lead to unpredictable results, including data corruption or crashes. Additionally, the analysis could not rule out the possibility that the source pointer may be null, which would also result in undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the classification and verdict both indicate a high-confidence, actionable problem.\n\n## In Context Remediation 0\nTo prevent undefined behavior when copying memory regions that may overlap, use a memory move function that is designed to handle overlapping regions safely. Replace the memory copy function with a memory move function, such as `memmove`, which guarantees correct behavior even if the source and destination overlap.\n\n```cpp\nmemmove(ptrs_[i], ptrs_[0], bytes_);\n```\n\nThis change ensures that the operation is safe regardless of whether the source and destination memory regions overlap.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## In Context Remediation 1\nBefore performing the memory copy, add a check to ensure that the source and destination pointers do not overlap. If overlap is possible, use a memory move function instead. For example:\n\n```cpp\nif (ptrs_[i] != ptrs_[0]) {\n    memcpy(ptrs_[i], ptrs_[0], bytes_);\n} else {\n    // No action needed or handle as appropriate\n}\n```\n\nAlternatively, always use `memmove` if overlap cannot be ruled out.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "55578fe2-3fdd-3444-838c-0d25c14a90a5",
              "help": {
                "text": "",
                "markdown": "This finding is classified as 'Likely Vulnerable: malloc result used without null check (possible null deref)', which indicates a high-confidence, actionable issue. The malloc call allocates memory for an int, but there is no check to ensure that the returned pointer is not NULL before it is dereferenced (first use is 'deref' and 'hasNullGuardBeforeUse' is false). This can lead to a null pointer dereference if memory allocation fails. The presence of a cast does not mitigate the risk. No zero guard or overflow guard is present, but for this allocation size (sizeof(int)), overflow is not a concern. The pointer is also passed to another call, but the primary risk is the immediate dereference without a null check.\n\n## In Context Remediation\nAlways check the result of malloc for NULL before dereferencing the pointer. This prevents undefined behavior if memory allocation fails. For example, if your original code is:\n\n```c\nvalue1 = (int*)malloc(sizeof(int));\n*value1 = 42;\n```\n\nYou should add a null check before using the pointer:\n\n```c\nvalue1 = (int*)malloc(sizeof(int));\nif (value1 == NULL) {\n    // Handle allocation failure, e.g., print error and exit or return\n    fprintf(stderr, \"Memory allocation failed\\n\");\n    exit(EXIT_FAILURE);\n}\n*value1 = 42;\n```\n\nThis ensures that your program does not attempt to dereference a NULL pointer, which would cause a crash or undefined behavior.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "69a5efe2-c80c-3a59-914e-e79db7e3a27e",
              "help": {
                "text": "",
                "markdown": "This finding is classified as 'Likely Vulnerable' because the result of a malloc call is used (dereferenced) without a preceding check for NULL. The malloc call allocates memory for an int, and the first use of the pointer is a dereference on the next line, with no null guard present. This pattern can lead to a null pointer dereference if malloc fails and returns NULL, which is a genuine risk for program stability and security. The presence of a cast does not mitigate the risk. No zero guard or overflow guard is present, but for this allocation size (sizeof(int)), overflow is not a concern. The pointer is also passed to another call, but the primary risk is the immediate dereference without a null check.\n\n## In Context Remediation\nTo prevent a possible null pointer dereference after memory allocation, always check the result of malloc before using the pointer. For example, if your original code is:\n\n```c\nvalue = (int*)malloc(sizeof(int));\n*value = 42;\n```\n\nYou should add a null check immediately after the allocation:\n\n```c\nvalue = (int*)malloc(sizeof(int));\nif (value == NULL) {\n    // Handle allocation failure, e.g., print error and exit or return\n    fprintf(stderr, \"Memory allocation failed\\n\");\n    exit(EXIT_FAILURE);\n}\n*value = 42;\n```\n\nThis ensures that if malloc fails and returns NULL, the program will not attempt to dereference a null pointer, preventing undefined behavior or a crash.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "29051d0c-0d46-3fa1-8ac3-da392849caba",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using unsafe C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `atoi()`, you can use `std::stoi()` which throws an exception if the conversion fails or if the converted value is out of range.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\n#include <cstdlib>\n#include <string>\n\n// ...\n\ntry {\n    size = std::stoi(getenv(\"SIZE\"));\n} catch (const std::invalid_argument& ia) {\n    // Handle the exception\n} catch (const std::out_of_range& oor) {\n    // Handle the exception\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstdlib` for `getenv()`\n- `string` for `std::stoi()`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n\nPlease note that the links are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189",
                  "29051d0c-0d46-3fa1-8ac3-da392849caba"
                ]
              }
            },
            {
              "id": "6e59e117-278d-316a-9297-be1b6c15d55b",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using unsafe C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `atoi()`, you can use `std::stoi()` which throws an exception if the conversion fails or if the converted value is out of range.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\n#include <cstdlib>\n#include <string>\n\n// ...\n\ntry {\n    size = std::stoi(getenv(\"SIZE\"));\n} catch (const std::invalid_argument& ia) {\n    // Handle the exception\n} catch (const std::out_of_range& oor) {\n    // Handle the exception\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstdlib` for `getenv()`\n- `string` for `std::stoi()`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n\nPlease note that the links are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189",
                  "6e59e117-278d-316a-9297-be1b6c15d55b"
                ]
              }
            },
            {
              "id": "f287a1a4-adbc-3e2c-8899-cecd7645cf60",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform bounds checking or handle errors more gracefully. In this case, consider using `strtol()` or `sscanf()` instead of `atoi()`. Always validate and sanitize input data.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n#include <climits>\n#include <cerrno>\n\nconst char* rankStr = getenv(\"RANK\");\nif(rankStr == NULL) {\n    // handle error\n}\n\nchar* end;\nlong rank = strtol(rankStr, &end, 10);\nif (end == rankStr || *end != '\\0' || errno == ERANGE || rank > INT_MAX || rank < INT_MIN) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\n- cstdlib\n- climits\n- cerrno\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)"
              },
              "properties": {
                "tags": [
                  "DS154189",
                  "f287a1a4-adbc-3e2c-8899-cecd7645cf60"
                ]
              }
            },
            {
              "id": "93d4f378-bb8f-3485-9054-d65d89495bc5",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform bounds checking or handle errors more gracefully. In this case, consider using `strtol()` or `sscanf()` instead of `atoi()`. Always validate and sanitize input data.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n#include <climits>\n#include <cerrno>\n\nconst char* rankStr = getenv(\"RANK\");\nif(rankStr == NULL) {\n    // handle error\n}\n\nchar* end;\nlong rank = strtol(rankStr, &end, 10);\nif (end == rankStr || *end != '\\0' || errno == ERANGE || rank > INT_MAX || rank < INT_MIN) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\n- cstdlib\n- climits\n- cerrno\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)"
              },
              "properties": {
                "tags": [
                  "DS154189",
                  "93d4f378-bb8f-3485-9054-d65d89495bc5"
                ]
              }
            },
            {
              "id": "304bdfce-cdf2-3708-9ca3-0ebd7ce2073b",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, and other security issues. In the provided code snippet, the function `getenv()` is used, which can lead to security vulnerabilities. This function returns a pointer to the value in the environment, or NULL if there is no match. The returned string should not be modified by the program, but it can be overwritten by a subsequent call to `getenv()`, `setenv()`, or `unsetenv()`.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. In this case, consider using a safer method to retrieve environment variables.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // for std::getenv\n\nconst char* prefix = std::getenv(\"PREFIX\");\nif (!prefix) {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\n- cstdlib\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "67416a2b-fd6a-32b6-934b-f35f6e88532f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nProduction Code Debugging Vulnerability in C++ refers to the situation where debugging code or debugging commands are inadvertently left in the production code. This can lead to a variety of security issues, including unauthorized access, information disclosure, and even remote code execution. Debugging code often contains sensitive information or functionality that should not be exposed in a production environment.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always remove debugging code or commands before deploying to production.\n2. Use preprocessor directives to ensure debugging code is not included in the production build.\n3. Regularly review and audit your code to ensure no debugging code has been left in.\n4. Use automated tools to check for common debugging commands or code snippets.\n\n## Source Code Fix Recommendation\n\nIf you have a piece of code like this:\n\n```cpp\n#define DEBUG\n\n#ifdef DEBUG\n    cout << \"Debugging information: \" << sensitive_info << endl;\n#endif\n\n// Production code here\n```\n\nYou should remove or comment out the `#define DEBUG` line before deploying to production:\n\n```cpp\n//#define DEBUG\n\n#ifdef DEBUG\n    cout << \"Debugging information: \" << sensitive_info << endl;\n#endif\n\n// Production code here\n```\n\n## Library Dependencies\n\nThe code example provided does not require any additional library dependencies.\n\n## References\n\n- [OWASP Code Review Guide](https://owasp.org/www-project-code-review-guide/)\n- [CWE-489: Leftover Debug Code](https://cwe.mitre.org/data/definitions/489.html)"
              },
              "properties": {
                "tags": [
                  "DS162092"
                ]
              }
            },
            {
              "id": "d0703e7c-26bc-3775-8a0a-049ba7c78d74",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Debug Code in Production Vulnerability\" refers to the situation where debug code is accidentally left in the production environment. This can lead to a variety of security issues, including information disclosure, unauthorized access, and even remote code execution. In C++, this can occur when debug statements that print sensitive information to the console or log files are not removed before the code is deployed to production.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, follow these general guidelines:\n\n- Always remove or disable debug code before deploying to production.\n- Use preprocessor directives to ensure debug code is not included in production builds.\n- Regularly review your codebase for leftover debug code.\n- Use automated tools to scan for potential debug code in production.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use preprocessor directives to ensure debug code is not included in production builds in C++:\n\n```cpp\n// Debug code\n#ifdef DEBUG\n    std::cout << \"Debug information: \" << sensitive_info << std::endl;\n#endif\n```\n\nIn this example, the debug code will only be included if the DEBUG preprocessor symbol is defined. This symbol should be defined in your development environment, but not in your production environment.\n\n## Library Dependencies\n\nThe code example does not require any additional library dependencies.\n\n## References\n\n- [CWE-489: Leftover Debug Code](https://cwe.mitre.org/data/definitions/489.html)"
              },
              "properties": {
                "tags": [
                  "DS162092",
                  "d0703e7c-26bc-3775-8a0a-049ba7c78d74"
                ]
              }
            },
            {
              "id": "9cd260ef-3bd1-3171-9d43-1a61f2252cba",
              "help": {
                "text": "",
                "markdown": "## Description\n\nProduction Code Debugging Vulnerability in C++ refers to the situation where debugging code or debugging commands are inadvertently left in the production code. This can lead to a variety of security issues, including unauthorized access, information disclosure, and even remote code execution. Debugging code often contains sensitive information or functionality that should not be exposed in a production environment.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always remove debugging code or commands before deploying to production.\n2. Use preprocessor directives to ensure debugging code is not included in the production build.\n3. Regularly review and audit your code to ensure no debugging code has been left in.\n4. Use automated tools to check for common debugging commands or code snippets.\n\n## Source Code Fix Recommendation\n\nIf you have a piece of code like this:\n\n```cpp\n#define DEBUG\n\n#ifdef DEBUG\n    cout << \"Debugging information: \" << sensitive_info << endl;\n#endif\n\n// Production code here\n```\n\nYou should remove or comment out the `#define DEBUG` line before deploying to production:\n\n```cpp\n//#define DEBUG\n\n#ifdef DEBUG\n    cout << \"Debugging information: \" << sensitive_info << endl;\n#endif\n\n// Production code here\n```\n\n## Library Dependencies\n\nThe code example provided does not require any additional library dependencies.\n\n## References\n\n- [OWASP Code Review Guide](https://owasp.org/www-project-code-review-guide/)\n- [CWE-489: Leftover Debug Code](https://cwe.mitre.org/data/definitions/489.html)"
              },
              "properties": {
                "tags": [
                  "DS162092",
                  "9cd260ef-3bd1-3171-9d43-1a61f2252cba"
                ]
              }
            },
            {
              "id": "13167f9c-f485-3cf5-a9a2-45fa8f21395a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `getenv` function is used, which can lead to security vulnerabilities. The `getenv` function returns a pointer to a string that is associated with the matched environment variable name passed as input. If the specified environment variable is not found, the function returns a null pointer. This can lead to null pointer dereferencing issues if not properly checked.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. Always validate and sanitize input from untrusted sources. Be aware of the potential security implications of using certain C library functions.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // for getenv\n#include <string>  // for std::string\n\nstd::string rank;\nchar* tmp = std::getenv(\"RANK\");\nif (tmp == nullptr) {\n    // handle error, e.g., set rank to a default value\n    rank = \"default\";\n} else {\n    rank = tmp;\n}\n```\n\n## Library Dependencies\n\n- `<cstdlib>`: This header defines several general purpose functions, including dynamic memory management, random number generation, communication with the environment, integer arithmetics, searching, sorting and converting.\n\n- `<string>`: This header introduces string types, character traits and a set of converting functions.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-628: Function Call with Incorrectly Specified Arguments](https://cwe.mitre.org/data/definitions/628.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "c9b40425-0bde-3795-a05b-24ee4f4f1712",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `getenv` function is used, which can lead to security vulnerabilities. The `getenv` function returns a pointer to a string that is associated with the matched environment variable name. If the specified environment variable is not found, the function returns a null pointer. This can lead to null pointer dereferencing issues if not properly checked.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. In this case, consider using the `std::getenv` function from the C++ Standard Library, which is a safer alternative to the C `getenv` function. Always check the returned pointer before using it.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\n#include <cstdlib>\n\nconst char* size = std::getenv(\"SIZE\");\nif (size != nullptr) {\n    // Use 'size' variable\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- cstdlib\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-628: Function Call with Incorrectly Specified Arguments](https://cwe.mitre.org/data/definitions/628.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "24b06255-3b8d-319c-8be3-af2341ed9a3b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the `getenv` function is used, which can lead to security vulnerabilities if not properly handled. The `getenv` function returns a pointer to a string that is associated with the matched environment variable name. If the specified environment variable is not found, the function returns a null pointer. This can lead to null pointer dereferencing if not properly checked.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to avoid using unsafe C functions where possible and instead use safer alternatives provided by the C++ standard library. If the use of such functions is unavoidable, ensure that proper error checking and handling is in place.\n\n## Source Code Fix Recommendation\n\nIn this case, the code is checking if the environment variables \"PREFIX\", \"SIZE\", and \"RANK\" are set. If any of them is not set, it will return a null pointer which can lead to null pointer dereferencing. To fix this, you can add proper error handling after each `getenv` call:\n\n```cpp\nchar* prefix = getenv(\"PREFIX\");\nchar* size = getenv(\"SIZE\");\nchar* rank = getenv(\"RANK\");\n\nif (prefix == nullptr || size == nullptr || rank == nullptr) {\n    // Handle error here, e.g., exit the program or throw an exception\n    std::cerr << \"Required environment variables are not set\" << std::endl;\n    exit(1);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the `cstdlib` library for the `getenv` function and the `iostream` library for error output.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-628: Function Call with Incorrectly Specified Arguments](https://cwe.mitre.org/data/definitions/628.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "beae45ff-f160-3097-b4f3-484ade617825",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `strerror` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror`. Instead, use thread-safe alternatives such as `strerror_r` in POSIX or `strerror_s` in Windows. \n\n## Source Code Fix Recommendation\n\nReplace the `strerror` function with `strerror_r`:\n\n```cpp\nchar buf[1024];\nGLOO_ENFORCE_NE(rv, -1, \"epoll_ctl: \", strerror_r(errno, buf, sizeof(buf)))\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `errno.h`: for `errno`\n- `string.h`: for `strerror`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "19572b35-2996-3c12-ad9b-5dfbd5277446",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Production Debug Code Presence\" vulnerability refers to the situation where debug code is accidentally left in the production environment. This can lead to a variety of security issues, including unauthorized access, information disclosure, and even remote code execution. In C++ programming, this vulnerability can occur if the debug code is not properly managed and removed before the application is deployed in a production environment.\n\nIn the provided code snippet, the `gloo::transport::tcp::CreateDevice(\"localhost\")` function is used, which might be part of a debug code. If this code is left in the production environment, it could potentially expose sensitive information or allow unauthorized access.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n- Always remove debug code or any code that is not necessary for the production environment before deploying the application.\n- Use preprocessor directives to ensure that debug code is not compiled into the final production build.\n- Regularly review and audit the code to ensure that no debug code is left in the production environment.\n- Use automated tools to detect and remove debug code.\n\n## Source Code Fix Recommendation\n\nThe fix would involve removing the debug code or wrapping it with preprocessor directives. Here is an example:\n\n```cpp\n#ifndef NDEBUG\ndev = gloo::transport::tcp::CreateDevice(\"localhost\")\n#endif\n```\n\nIn this example, the debug code will only be compiled if the `NDEBUG` macro is not defined. This macro is usually not defined in the production build, so the debug code will be excluded.\n\n## Library Dependencies\n\nThe provided code snippet seems to be using the Gloo library for collective communications over TCP. Therefore, the Gloo library would be a required dependency.\n\n## References\n\n- [CWE-489: Leftover Debug Code](https://cwe.mitre.org/data/definitions/489.html)\n\nPlease note that the links provided are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS162092"
                ]
              }
            },
            {
              "id": "3e3dc112-dcaf-3b74-a4cf-b5adab26662e",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `strerror` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror`. Instead, use thread-safe alternatives such as `strerror_r` in POSIX or `strerror_s` in Windows. \n\n## Source Code Fix Recommendation\n\nReplace the `strerror` function with `strerror_r`:\n\n```cpp\nchar buf[1024];\nGLOO_ENFORCE_NE(rv, -1, \"epoll_ctl: \", strerror_r(errno, buf, sizeof(buf)))\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `errno.h`: for `errno`\n- `string.h`: for `strerror`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "dec4341d-62fc-34c2-ad1b-b8046dda5d15",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ refers to the use of certain C library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other types of security issues. These functions are often prohibited in secure coding standards due to their inherent risks.\n\nIn the provided code snippet, the function `strerror(errno)` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment. This is because `strerror` returns a pointer to a static buffer that is overwritten by each call, so concurrent calls from different threads can overwrite the data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use thread-safe alternatives to unsafe C functions. In the case of `strerror`, a safer alternative is `strerror_r` in POSIX systems or `strerror_s` in Windows.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror(errno)` function with `strerror_r(errno, buf, sizeof buf)` or `strerror_s(buf, sizeof buf, errno)` depending on your platform. Ensure to define a buffer `buf` of appropriate size.\n\n```cpp\nchar buf[1024];\nGLOO_ENFORCE_NE(fd_, -1, \"epoll_create: \", strerror_r(errno, buf, sizeof buf))\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<errno.h>`: for `errno`\n- `<string.h>`: for `strerror_r` or `strerror_s`\n- `gloo/common/logging.h`: for `GLOO_ENFORCE_NE`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "7c45b348-6d3d-3d8f-8315-5d9398c422be",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using unsafe C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `atoi()`, you can use `std::stoi()` which throws an exception if the conversion fails or if the converted value is out of range.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\n#include <cstdlib>\n#include <string>\n\n// ...\n\ntry {\n    size = std::stoi(getenv(\"SIZE\"));\n} catch (const std::invalid_argument& ia) {\n    // Handle the exception\n} catch (const std::out_of_range& oor) {\n    // Handle the exception\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstdlib` for `getenv()`\n- `string` for `std::stoi()`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n\nPlease note that the links are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189",
                  "7c45b348-6d3d-3d8f-8315-5d9398c422be"
                ]
              }
            },
            {
              "id": "2b42892c-ab0b-35da-bfb3-97745b617eff",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using unsafe C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `atoi()`, you can use `std::stoi()` which throws an exception if the conversion fails or if the converted value is out of range.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\n#include <cstdlib>\n#include <string>\n\n// ...\n\ntry {\n    size = std::stoi(getenv(\"SIZE\"));\n} catch (const std::invalid_argument& ia) {\n    // Handle the exception\n} catch (const std::out_of_range& oor) {\n    // Handle the exception\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstdlib` for `getenv()`\n- `string` for `std::stoi()`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n\nPlease note that the links are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189",
                  "2b42892c-ab0b-35da-bfb3-97745b617eff"
                ]
              }
            },
            {
              "id": "a3d938ca-7024-3b3a-adc2-2803f47a59da",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform bounds checking or handle errors more gracefully. In this case, consider using `strtol()` or `sscanf()` instead of `atoi()`. Always validate and sanitize input data.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n#include <climits>\n#include <cerrno>\n\nconst char* rankStr = getenv(\"RANK\");\nif(rankStr == NULL) {\n    // handle error\n}\n\nchar* end;\nlong rank = strtol(rankStr, &end, 10);\nif (end == rankStr || *end != '\\0' || errno == ERANGE || rank > INT_MAX || rank < INT_MIN) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\n- cstdlib\n- climits\n- cerrno\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)"
              },
              "properties": {
                "tags": [
                  "DS154189",
                  "a3d938ca-7024-3b3a-adc2-2803f47a59da"
                ]
              }
            },
            {
              "id": "76ed438d-d886-34d4-b760-ae984955c673",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform bounds checking or handle errors more gracefully. In this case, consider using `strtol()` or `sscanf()` instead of `atoi()`. Always validate and sanitize input data.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n#include <climits>\n#include <cerrno>\n\nconst char* rankStr = getenv(\"RANK\");\nif(rankStr == NULL) {\n    // handle error\n}\n\nchar* end;\nlong rank = strtol(rankStr, &end, 10);\nif (end == rankStr || *end != '\\0' || errno == ERANGE || rank > INT_MAX || rank < INT_MIN) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\n- cstdlib\n- climits\n- cerrno\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)"
              },
              "properties": {
                "tags": [
                  "DS154189",
                  "76ed438d-d886-34d4-b760-ae984955c673"
                ]
              }
            },
            {
              "id": "5c29cc7a-caa2-3d12-9a30-b9d0e1a63481",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `getenv` function is used, which can lead to security vulnerabilities. The `getenv` function returns a pointer to a string that is associated with the matched environment variable name passed as input. If the specified environment variable is not found, the function returns a null pointer. This can lead to null pointer dereferencing issues if not properly checked.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. Always validate and sanitize input from untrusted sources. Be aware of the potential security implications of using certain C library functions.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // for getenv\n#include <string>  // for std::string\n\nstd::string rank;\nchar* tmp = std::getenv(\"RANK\");\nif (tmp == nullptr) {\n    // handle error, e.g., set rank to a default value\n    rank = \"default\";\n} else {\n    rank = tmp;\n}\n```\n\n## Library Dependencies\n\n- `<cstdlib>`: This header defines several general purpose functions, including dynamic memory management, random number generation, communication with the environment, integer arithmetics, searching, sorting and converting.\n\n- `<string>`: This header introduces string types, character traits and a set of converting functions.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-628: Function Call with Incorrectly Specified Arguments](https://cwe.mitre.org/data/definitions/628.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "698884a4-369f-39e7-a091-19a1f6de3cbd",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, and other security issues. In the provided code snippet, the function `getenv()` is used, which can lead to security vulnerabilities. This function returns a pointer to the value in the environment, or NULL if there is no match. The returned string should not be modified by the program, but it can be overwritten by a subsequent call to `getenv()`, `setenv()`, or `unsetenv()`.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. In this case, consider using a safer method to retrieve environment variables.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // for std::getenv\n\nconst char* prefix = std::getenv(\"PREFIX\");\nif (!prefix) {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\n- cstdlib\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "3011b382-c622-32cb-a083-8502d8de41af",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `getenv` function is used, which can lead to security vulnerabilities. The `getenv` function returns a pointer to a string that is associated with the matched environment variable name. If the specified environment variable is not found, the function returns a null pointer. This can lead to null pointer dereferencing issues if not properly checked.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. In this case, consider using the `std::getenv` function from the C++ Standard Library, which is a safer alternative to the C `getenv` function. Always check the returned pointer before using it.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\n#include <cstdlib>\n\nconst char* size = std::getenv(\"SIZE\");\nif (size != nullptr) {\n    // Use 'size' variable\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- cstdlib\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-628: Function Call with Incorrectly Specified Arguments](https://cwe.mitre.org/data/definitions/628.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "d19b9ac8-87ee-3e18-a4db-ceb17ecd9192",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the `getenv` function is used, which can lead to security vulnerabilities if not properly handled. The `getenv` function returns a pointer to a string that is associated with the matched environment variable name. If the specified environment variable is not found, the function returns a null pointer. This can lead to null pointer dereferencing if not properly checked.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to avoid using unsafe C functions where possible and instead use safer alternatives provided by the C++ standard library. If the use of such functions is unavoidable, ensure that proper error checking and handling is in place.\n\n## Source Code Fix Recommendation\n\nIn this case, the code is checking if the environment variables \"PREFIX\", \"SIZE\", and \"RANK\" are set. If any of them is not set, it will return a null pointer which can lead to null pointer dereferencing. To fix this, you can add proper error handling after each `getenv` call:\n\n```cpp\nchar* prefix = getenv(\"PREFIX\");\nchar* size = getenv(\"SIZE\");\nchar* rank = getenv(\"RANK\");\n\nif (prefix == nullptr || size == nullptr || rank == nullptr) {\n    // Handle error here, e.g., exit the program or throw an exception\n    std::cerr << \"Required environment variables are not set\" << std::endl;\n    exit(1);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the `cstdlib` library for the `getenv` function and the `iostream` library for error output.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-628: Function Call with Incorrectly Specified Arguments](https://cwe.mitre.org/data/definitions/628.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "ad39fb49-1598-38e5-b9a1-3ef8ccdc39b4",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions. The analysis observed that the source and destination pointers may alias each other (for example, through an assignment like 'in = out'), which can cause undefined behavior when using memory copy functions such as memcpy. There are no explicit checks or guards in the code to prevent this overlap, and both the source and destination pointers are confirmed to be non-null before the call. The absence of a length derived from the destination's capacity and the lack of a null-terminator assignment further increase the risk. The verdict is supported by the high-confidence 'GENUINE' label and the overlap evidence.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping regions safely. For example, change the code to:\n\n```cpp\nmemmove(out->ptr, in->ptr, out->size);\n```\n\nThis ensures that the copy operation is performed correctly even if `in->ptr` and `out->ptr` refer to overlapping memory areas.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "76dff85e-37a8-3bc5-9688-4b1650b68c21",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the destination and source pointers may refer to overlapping memory areas, which is not allowed for the memcpy function and can result in unpredictable program behavior. Additionally, the source pointer may be null at this call site, which further increases the risk of undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the function does not ensure that the source and destination are distinct and valid. These factors make this a high-confidence, actionable issue that should be addressed to prevent potential security and stability problems.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping source and destination regions safely. For the code in question, change the function call as follows:\n\n```cpp\nmemmove(ptrs_[i], ptrs_[rootPointerRank_], bytes_);\n```\n\nThis ensures that even if the source and destination pointers refer to overlapping memory, the copy will be performed correctly without causing undefined behavior. Additionally, consider adding checks to ensure that the source pointer is not null before performing the copy to avoid null pointer dereference issues.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "4a6c9f7c-8274-3b47-9943-41b33b82a42f",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the data flow analysis. Additionally, there is a risk that the source pointer could be null, since there is no prior check ensuring it is non-null. The classification specifically highlights undefined behavior risk, and the verdict confirms this is a high-confidence issue. No mitigating factors such as explicit bounds checks, null checks, or overlap guards are present.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n```cpp\nif (src != nullptr && &src_ != src) {\n    memcpy(&src_, src, sizeof(src_));\n} else if (src != nullptr) {\n    // If overlap is possible, use memmove\n    memmove(&src_, src, sizeof(src_));\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3dbeca40-dd7d-3aa6-9fea-8092efc20793",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the `getenv` function is used, which is a potential security risk. The `getenv` function returns a pointer to a string that is stored in a static memory location. If this function is called multiple times, it can overwrite the previous value, leading to potential data races in multithreaded programs.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. In the case of `getenv`, consider using a thread-safe alternative if available, or protect the call with a mutex if the environment variable is accessed from multiple threads.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n#include <mutex>\n\nstd::mutex mtx;\n\n// ...\n\nmtx.lock();\nchar* universe_size = std::getenv(\"OMPI_UNIVERSE_SIZE\");\nresult.mpi = (universe_size != nullptr);\nmtx.unlock();\n```\n\nIn this code, the `getenv` function is protected by a mutex to prevent data races.\n\n## Library Dependencies\n\nThe code requires the following libraries:\n\n- cstdlib: for `std::getenv`\n- mutex: for `std::mutex`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "bd9fa479-fb9b-3b10-81fb-7dd0365b71ec",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it can lead to buffer overflow vulnerabilities if not used correctly. This is because `strlen` does not check for null termination and will continue reading memory until it encounters a null byte. If the string is not null-terminated, `strlen` could read beyond the allocated memory, leading to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string handling functions that include a length parameter. This allows you to specify the maximum number of characters to be read, preventing buffer overflows. \n\nIn C++, it is generally recommended to use the string class instead of C-style strings. The string class includes many functions that are safer and easier to use than the C-style string functions.\n\n## Source Code Fix Recommendation\n\nIn the provided code, the `strlen` function is used to determine the length of `optarg`. This can be replaced with the `std::string` constructor that takes a C-style string as an argument, which automatically determines the length of the string in a safe manner.\n\nHere is the fixed code:\n\n```cpp\nresult.caPath = std::string(optarg);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string`: This is a standard C++ library for handling strings.\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "ca63e922-baab-3e7d-995e-2aba08bfabba",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it does not check for null termination. This means that if a string is not properly null-terminated, `strlen` will continue reading memory until it encounters a null byte, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string handling functions that include length parameters, such as `strnlen` or `strncpy`. These functions take an additional argument specifying the maximum length of the string to be processed, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nReplace the `strlen` function with the `strnlen` function, which includes a length parameter:\n\n```cpp\nresult.caFile = std::string(optarg, strnlen(optarg, MAX_LENGTH));\n```\n\nIn this code, `MAX_LENGTH` should be defined as the maximum expected length of `optarg`.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string`: for the `std::string` class.\n- `cstring`: for the `strlen` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "f8a85ba7-f1fd-3a88-af26-840e6bd705cb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it does not include the null character at the end of the string. This can lead to buffer overflow vulnerabilities if the length of the string is not properly checked before it is used.\n\nIn the provided code snippet, `strlen(optarg)` is used to determine the length of the string `optarg`. If `optarg` is not null-terminated, `strlen(optarg)` could return a value larger than the actual size of the string, leading to a buffer overflow when the string is copied into `result.cert`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that your strings are null-terminated before using functions like `strlen`. Additionally, consider using safer alternatives to `strlen` that include bounds checking, such as `strnlen`.\n\n## Source Code Fix Recommendation\n\nA safer version of the code snippet might look like this:\n\n```cpp\nsize_t length = strnlen(optarg, MAX_LENGTH);\nresult.cert = std::string(optarg, length);\n```\n\nIn this version, `strnlen` is used instead of `strlen`. `strnlen` will only count up to `MAX_LENGTH` characters, preventing a buffer overflow if `optarg` is not null-terminated.\n\n## Library Dependencies\n\nThe code snippet requires the following library dependencies:\n\n- `<string>` for `std::string`\n- `<cstring>` for `strlen` and `strnlen`\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "3cd67c0a-f7e1-3559-aa4c-3142d58d532f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it does not check for null termination. This means that if a string is not properly null-terminated, `strlen` will continue reading memory until it encounters a null byte, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nThis vulnerability is particularly dangerous because it can lead to serious security issues, such as arbitrary code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string handling functions that do not rely on null termination to determine the length of the string. In C++, this can be achieved by using the `std::string` class, which automatically keeps track of the string length and ensures null termination.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the vulnerability can be fixed by simply removing the `strlen` function. The `std::string` constructor can take a C-string as an argument and automatically determine its length:\n\n```cpp\nresult.pkey = std::string(optarg);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string`: This is a standard C++ library for handling strings.\n- `getopt`: This is a library used for parsing command line arguments.\n\n## References\n\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are subject to change and may not be accessible at all times. Always ensure to use the latest and most reliable resources when dealing with security vulnerabilities."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "2df6955a-5f11-3873-bf6a-8941b4726f3f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, and integer overflow attacks. In this case, the `atoi()` function is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `atoi()`, you can use `std::stoi()`, which throws an exception if the conversion fails or if the converted value is out of range.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\ntry {\n    result.messages = std::stoi(optarg);\n} catch (std::invalid_argument& e) {\n    // Handle exception: conversion failed\n} catch (std::out_of_range& e) {\n    // Handle exception: number out of range for int\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `cstdlib` (for `atoi()`)\n- `string` (for `std::stoi()`)\n\n## References\n\n- [CWE-681: Incorrect Conversion between Numeric Types](https://cwe.mitre.org/data/definitions/681.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "8c776783-f0ff-305b-82ab-552b39fa1f66",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `strlen(optarg)` is used to determine the length of `optarg`. If `optarg` is not null-terminated, this can lead to the aforementioned issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, ensure that all strings are null-terminated before passing them to `strlen`. Alternatively, consider using safer functions that take the size of the buffer as an argument, such as `strnlen`, which will not read past the specified length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(optarg)` with `strnlen(optarg, MAX_LEN)`, where `MAX_LEN` is the maximum expected length of `optarg`. This will prevent `strnlen` from reading past the end of `optarg`, even if it is not null-terminated.\n\n```cpp\nresult.sharedPath = std::string(optarg, strnlen(optarg, MAX_LEN));\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<string>`: for `std::string`\n- `<cstring>`: for `strlen` and `strnlen`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "c3e5f9ba-c15a-34f0-9201-7a9e2e53342d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Identified\" is a vulnerability that arises when a C++ program uses a function that is considered unsafe. This is because these functions do not perform bounds checking or other necessary validation, which can lead to buffer overflow attacks, memory corruption, and other security issues. In this case, the function `atoi()` is used, which is considered unsafe because it does not check for overflow or invalid input.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives that perform necessary validation. For instance, instead of `atoi()`, you can use `strtol()` or `sscanf()`, which provide error checking.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()`. Here is how you can do it:\n\n```cpp\nchar *end;\nlong int value = strtol(optarg, &end, 10);\nif (end == optarg || *end != '\\0' || errno == ERANGE) {\n    // handle error\n} else {\n    result.base = value;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `stdlib.h`: for `strtol()`\n- `errno.h`: for `errno`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "f8a65901-b084-3031-b427-923f685177bb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the function `atoi()` is used, which can lead to integer overflow or underflow if the input string represents a number outside the range of representable integer values.\n\n## Mitigation Advice\n\nAvoid using unsafe C functions like `atoi()`. Instead, use safer alternatives that perform error checking. For example, the `strtol()` function can be used to convert a string to a long integer, and it provides a way to check for errors.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()`. Here's how you can do it:\n\n```cpp\nchar *end;\nlong int port = strtol(optarg, &end, 10);\nif (end == optarg || *end != '\\0' || errno == ERANGE) {\n    // handle error\n} else {\n    result.ibverbsPort = port;\n}\n```\n\nIn this code, `strtol()` is used to convert the string to a long integer. If the conversion is successful, the `end` pointer will point to the end of the string. If the conversion fails, `end` will point to the part of the string that couldn't be converted. The `errno` variable is checked to see if the conversion resulted in overflow or underflow.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `stdlib.h` for `strtol()`\n- `errno.h` for `errno`\n\n## References\n\n- [OWASP Prohibited C Functions](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html#prohibited-c-library-functions)\n- [CWE-681: Incorrect Conversion between Numeric Types](https://cwe.mitre.org/data/definitions/681.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "2d364472-da6b-34b1-9c15-ee6bbe4b2598",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or integer overflows. In this case, the function `atoi()` is used, which can lead to integer overflow or underflow if the input is not properly validated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or to perform proper input validation before using them. In the case of `atoi()`, it does not perform any error checking, so it can lead to undefined behavior if the input string cannot be converted to an integer. \n\n## Source Code Fix Recommendation\n\nA safer alternative to `atoi()` is `strtol()`, which performs error checking. Here is how you can use it:\n\n```cpp\nchar *end;\nlong int value = strtol(optarg, &end, 10);\n\nif (end == optarg || *end != '\\0' || errno == ERANGE) {\n    // handle error\n} else {\n    result.ibverbsIndex = value;\n}\n```\n\nIn this code, `strtol()` tries to convert `optarg` to a `long int`. If `optarg` does not contain any digits, `end` will be equal to `optarg`. If `optarg` contains any non-digit characters after the number, they will be stored in `*end`. If the number is too large or too small to fit in a `long int`, `errno` will be set to `ERANGE`.\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `stdlib.h` for `strtol()`\n- `errno.h` for `errno`\n\n## References\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "81dbaff4-95d0-3e61-9921-7deb3c40a79c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the function `atoi()` is used, which can lead to integer overflow or underflow if the input string represents a number outside the range of representable integer values.\n\n## Mitigation Advice\n\nAvoid using unsafe C functions like `atoi()`. Instead, use safer alternatives that perform bounds checking or error handling. For example, you can use `strtol()` or `sscanf()` for string to integer conversion, which provide error checking mechanisms.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()`. Here is an example of how to do it:\n\n```cpp\nchar *end;\nlong int value = strtol(optarg, &end, 10);\nif (end == optarg || *end != '\\0' || errno == ERANGE) {\n    // handle error\n} else {\n    result.threads = value;\n}\n```\n\nIn this code, `strtol()` is used to convert the string to a long integer. If the conversion is unsuccessful, `end` will point to the first invalid character in `optarg`, or `errno` will be set to `ERANGE` if the number is out of range.\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `stdlib.h` for `strtol()`\n- `errno.h` for `errno`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "e2c7d5ed-7db2-3fda-8f80-d0a6339e9da8",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, integer overflow, etc. In this case, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using C library functions that do not perform bounds checking or input validation. Instead, use safer alternatives provided by the C++ Standard Library. For `atoi()`, a safer alternative is `std::stoi()`, which throws an exception if the input string cannot be converted to an integer or if the converted value is out of the range of representable values by an `int`.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\ntry {\n    result.destinations = std::stoi(optarg);\n} catch (std::invalid_argument& e) {\n    // Handle the case where 'optarg' cannot be converted to an integer\n} catch (std::out_of_range& e) {\n    // Handle the case where the converted value is out of the range of representable values by an 'int'\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `cstdlib` (for `atoi()`)\n- `string` (for `std::stoi()`)\n\n## OWASP Resources\n\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-681: Incorrect Conversion between Numeric Types](https://cwe.mitre.org/data/definitions/681.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "a7692905-3771-3416-966a-7b1d4e8a0a9e",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, integer overflow, etc. In this case, the function `atoi()` is used, which is a standard C library function that converts a string into an integer. The problem with `atoi()` is that it does not handle errors well. If the input string cannot be converted into an integer, it returns zero, which can lead to unexpected behavior.\n\n## Mitigation Advice\n\nAvoid using C library functions that do not perform bounds checking or error checking. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `atoi()`, you can use `std::stoi()`, which throws an exception if the conversion fails.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\n#include <string>\n\ntry {\n    result.inputs = std::stoi(optarg);\n} catch (std::invalid_argument& e) {\n    // handle error\n} catch (std::out_of_range& e) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `cstdlib` for `atoi()`\n- `string` for `std::stoi()`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "24ab890a-c55a-33ed-952a-7adff6d4a167",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the `atoi()` function is used, which is a prohibited C function. This function converts a string to an integer and it does not handle errors properly. If the input string cannot be converted into an integer, it returns zero, which can lead to unexpected behavior.\n\n## Mitigation Advice\n\nAvoid using unsafe C functions. Instead, use safer alternatives that are available. For instance, instead of `atoi()`, you can use `strtol()` or `sscanf()`, which provide error checking. Always validate and sanitize user input to prevent injection attacks. \n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()`. Here is the fixed code:\n\n```cpp\n#include <cstdlib>\n#include <cctype>\n\nchar *end;\nlong val = strtol(optarg, &end, 10);\nif (end == optarg || *end != '\\0' || errno == ERANGE) {\n    // handle conversion error\n} else if (val == 1 || tolower(optarg[0]) == 't' || tolower(optarg[0]) == 'y') {\n    // proceed with the rest of the code\n}\n```\n\n## Library Dependencies\n\nThe code requires the following libraries:\n\n- cstdlib: for `strtol()`\n- cctype: for `tolower()`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "5e38f064-f633-3c39-811e-5584912118a7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the `atoi()` function is used, which is a prohibited C function. This function converts a string to an integer and it does not handle errors properly. If the input string cannot be converted into an integer, it returns zero, which can lead to unexpected behavior.\n\n## Mitigation Advice\n\nAvoid using unsafe C functions. Instead, use safer alternatives that are available. For instance, instead of `atoi()`, you can use `strtol()` or `sscanf()`, which provide error checking. Always validate and sanitize user input to prevent injection attacks. \n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()`. Here is the fixed code:\n\n```cpp\n#include <cstdlib>\n#include <cctype>\n\nchar *end;\nlong val = strtol(optarg, &end, 10);\nif (end == optarg || *end != '\\0' || errno == ERANGE) {\n    // handle conversion error\n} else if (val == 1 || tolower(optarg[0]) == 't' || tolower(optarg[0]) == 'y') {\n    // proceed with the rest of the code\n}\n```\n\n## Library Dependencies\n\nThe code requires the following libraries:\n\n- cstdlib: for `strtol()`\n- cctype: for `tolower()`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "efacfc8b-173e-303f-adb3-d67aa6346442",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, integer overflow, etc. In this case, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For `atoi()`, a safer alternative is `std::stoi()`, which throws an exception if the conversion fails or if the converted value is out of range.\n\n## Source Code Fix Recommendation\n\nReplace `atoi(optarg)` with `std::stoi(optarg)`. Here is the fixed code:\n\n```cpp\ntry {\n    result.iterationCount = std::stoi(optarg);\n} catch (std::invalid_argument& e) {\n    // Handle exception: conversion failed\n} catch (std::out_of_range& e) {\n    // Handle exception: converted value is out of range\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>` for `atoi()`\n- `<string>` for `std::stoi()`\n\n## References\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "a54dd078-0b74-3e95-a2ea-156a49004713",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the function `atoi()` is used, which is a standard C library function that converts a string to an integer. The problem with `atoi()` is that it does not perform any error checking. If the input string cannot be converted into an integer, it returns zero, which can lead to unexpected behavior.\n\n## Mitigation Advice\n\nAvoid using C library functions that do not perform error checking or can lead to buffer overflows. Instead, use safer alternatives provided by the C++ Standard Library. For example, instead of `atoi()`, you can use `std::stoi()`, which throws an exception if the conversion fails.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\ntry {\n    result.warmupIterationCount = std::stoi(optarg);\n} catch (std::invalid_argument& e) {\n    // Handle exception: the conversion could not be performed\n} catch (std::out_of_range& e) {\n    // Handle exception: the converted value would fall out of the range of the result type\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `cstdlib` (for `atoi()`)\n- `string` (for `std::stoi()`)\n\n## References\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "0d16502c-dac1-343a-8e9a-9ea348d9583b",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or integer overflow attacks. In this case, the function `atoi()` is used, which can lead to integer overflow or underflow if the input is not properly validated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For `atoi()`, a safer alternative would be `strtol()` or `sscanf()`. These functions provide error checking which can prevent integer overflow or underflow attacks.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()` or `sscanf()`. Here is an example of how to use `strtol()`:\n\n```cpp\nchar *end;\nlong int value = strtol(optarg, &end, 10);\nif (end == optarg || *end != '\\0' || errno == ERANGE) {\n    // handle error\n} else {\n    result.elements = value;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `stdlib.h` for `strtol()`\n- `errno.h` for `errno`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "fdbe6aa7-0ddf-3415-8463-4a69dcc9e504",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it can lead to buffer overflow vulnerabilities if not used correctly. This is because `strlen` does not check for the null character at the end of the string, which can lead to reading beyond the allocated memory if the string is not properly null-terminated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string handling functions that include bounds checking, such as `strnlen` or `strncpy`. These functions take an additional parameter that specifies the maximum number of characters to be copied or read, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nresult.transport = std::string(optarg, strnlen(optarg, MAX_LEN));\n```\n\nIn this code, `MAX_LEN` should be defined as the maximum expected length of `optarg`. This ensures that `strnlen` will not read beyond this length, even if `optarg` is not properly null-terminated.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string`: This is a standard C++ library that provides support for strings.\n- `cstring`: This is a standard C library that provides support for string handling functions like `strlen`.\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "7810f9db-7e92-3ebd-be8d-4010dd6c6b0d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other undefined behaviors.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character or by manually adding a null character at the end of your string. Additionally, consider using safer alternatives to `strlen`, such as `strnlen`, which takes an additional parameter specifying the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the vulnerability can be fixed by replacing `strlen` with `strnlen` and specifying a maximum length for the string. Here's how you can do it:\n\n```cpp\nsize_t max_length = 100; // replace with your maximum length\nresult.prefix = std::string(optarg, strnlen(optarg, max_length));\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string`: for the `std::string` class.\n- `cstring`: for the `strlen` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "4847d334-a37c-3472-919a-f08904d95f94",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, which is not allowed for memcpy and can result in unpredictable program behavior. Additionally, both the source and destination pointers may be null at this call site, and there are no explicit checks to prevent this. The classification and verdict both indicate a high-confidence issue that should be addressed to prevent undefined behavior and potential security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit checks to ensure that neither the source nor the destination pointers are null before performing the copy operation.\n\n```cpp\nif (bytes.data() != nullptr && &addr_ != nullptr) {\n    memmove(bytes.data(), &addr_, sizeof(addr_));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a9811300-2dc0-3a94-a43f-ba712fe27b8b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it can lead to buffer overflow vulnerabilities if not used correctly. This is because `strlen` does not check for null termination and will continue reading memory until it encounters a null byte. If the string is not null-terminated, `strlen` could read beyond the allocated memory, leading to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string handling functions that include length checks. In C++, this could be the `std::string` constructor that takes only a `char*` parameter. This constructor automatically calculates the length of the string in a safe manner.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nresult.redisHost = std::string(optarg);\n```\n\nIn this version, the `std::string` constructor automatically calculates the length of the string, mitigating the risk of a buffer overflow.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string`: This is a standard C++ library for handling strings.\n- `unistd.h`: This is a standard C library that provides access to the POSIX operating system API.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "9d8be6d3-e2ac-335a-b9c4-533c4b1541d0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the function `atoi()` is used, which can lead to integer overflow or underflow if the input string represents a number outside the range of representable integer values.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions that include proper error handling and boundary checks. For `atoi()`, a safer alternative could be `strtol()` or `sscanf()`, which provide error checking.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()` or `sscanf()`. Here is an example of how to use `strtol()`:\n\n```cpp\nchar *end;\nlong int port = strtol(optarg, &end, 10);\nif (end == optarg || *end != '\\0' || errno == ERANGE) {\n    // handle error\n} else {\n    result.redisPort = port;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `stdlib.h` for `strtol()`\n- `errno.h` for `errno`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "b42dc0bb-aaf4-31da-96ac-52e576a75c3c",
              "name": "Win32HardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol: Win32 - Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440077"
                ]
              }
            },
            {
              "id": "814b18fa-c7ae-30cc-bfac-593dcf0b1c71",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions. The analysis detected that the source and destination pointers may refer to overlapping memory areas, which is not allowed for the memcpy function and can result in unpredictable program behavior. Additionally, the source pointer may be null at this call site, which could also lead to a crash or undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the function verdict confirms this as a genuine issue. The destination pointer is guarded as non-null, but the source pointer is not, increasing the risk. The use of memcpy in this context is unsafe when overlap is possible; memmove should be used if overlap cannot be ruled out.\n\n## In Context Remediation\nReplace the use of memcpy with memmove to safely handle the case where the source and destination memory regions may overlap. memmove is designed to correctly copy memory even if the regions overlap, preventing undefined behavior. For example, change the code to:\n\n```cpp\nmemmove(out->ptr, in[context->rank]->ptr, out->size);\n```\n\nAdditionally, ensure that the source pointer is not null before calling memmove to avoid potential crashes:\n\n```cpp\nif (in[context->rank] && in[context->rank]->ptr) {\n    memmove(out->ptr, in[context->rank]->ptr, out->size);\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e7aa8d31-6ac7-3e92-9c9b-7a898e06ce46",
              "name": "Win32HardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol: Win32 - Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440077"
                ]
              }
            },
            {
              "id": "7bdbca30-24e7-327c-99e4-879c4effe401",
              "name": "Win32HardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "Win32 - Hard-coded SSL/TLS Protocol: Win32 - Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440077"
                ]
              }
            },
            {
              "id": "f888df33-e53b-32bd-9ada-751951bfe76a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the data flow analysis. Additionally, there is a risk that the source pointer could be null at runtime, since there is no prior check ensuring it is non-null. The destination is not likely to be null, but the overlap and null source risks make this a high-confidence, actionable issue. The use of a raw memory copy function without explicit overlap handling or null checks further increases the risk of undefined behavior or program crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid potential crashes.\n\n```cpp\nif (bytes.data() != nullptr) {\n    memmove(&addr_, bytes.data(), sizeof(addr_));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c7d97622-b1ff-392c-86e3-92511e584f26",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the function `atoi()` is used, which can lead to integer overflow or underflow if the input string represents a number outside the range of representable integer values.\n\n## Mitigation Advice\n\nAvoid using unsafe C functions like `atoi()`. Instead, use safer alternatives that perform error checking. For example, you can use `strtol()` or `sscanf()` for string to integer conversion, which provide error checking mechanisms.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()`. Here's how you can do it:\n\n```cpp\nchar *end;\nlong int value = strtol(optarg, &end, 10);\nif (end == optarg || *end != '\\0' || errno == ERANGE) {\n    // handle error\n} else {\n    result.contextSize = value;\n}\n```\n\nIn this code, `strtol()` is used to convert the string to a long integer. If the conversion is successful, the converted value is assigned to `result.contextSize`. If the conversion fails, an error is handled.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `stdlib.h`: for `strtol()`\n- `errno.h`: for `errno`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "ab8929f6-6b17-3a0c-bf43-f8532908fa4c",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, integer overflow, etc. In this case, the function `atoi()` is used, which can lead to integer overflow if the input string represents a number larger than `INT_MAX`.\n\n## Mitigation Advice\n\nAvoid using C library functions that do not perform bounds checking or input validation. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `atoi()`, use `std::stoi()` which throws an exception if the input string represents a number outside the range of `int`.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`. Here is the fixed code:\n\n```cpp\n#include <string>\n\ntry {\n    result.contextRank = std::stoi(optarg);\n} catch (std::out_of_range& e) {\n    // Handle the exception\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<string>`: This is a standard C++ library for string manipulation.\n\n## References\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "0e935b3e-3916-32a7-be68-7c7e3069fa49",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions in the code. These functions are prone to various types of attacks, such as buffer overflow attacks, format string vulnerabilities, integer overflow, etc. In the provided code snippet, the function `strerror()` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives like `strerror_r()`. Also, ensure to validate and sanitize all inputs to prevent buffer overflow and other types of attacks.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with `strerror_r()`. Here is the fixed code:\n\n```cpp\nchar buf[1024];\nGLOO_ENFORCE(mr_ != nullptr, \"ibv_reg_mr: \", strerror_r(errno, buf, sizeof(buf)))\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `errno.h`: for `errno`\n- `string.h`: for `strerror()`\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Prohibited C Functions](https://owasp.org/www-community/attacks/Format_string_attack)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n- [CWE-477: Use of Obsolete Function](https://cwe.mitre.org/data/definitions/477.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "1c19a17a-d0b2-3ead-95ed-ec96e7cb77e9",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "9d6b3b2b-4710-39d8-9f80-14973da4d408",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "70501dc7-6198-3fcd-b90e-abb0768c8744",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Win32 - Hard-coded SSL/TLS Protocol"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/tls/openssl.cc"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 11,
                  "endLine": 52,
                  "endColumn": 37,
                  "charOffset": 1501,
                  "charLength": 26,
                  "snippet": {
                    "text": "SSL_CTX_set_security_level",
                    "rendered": {
                      "text": "SSL_CTX_set_security_level",
                      "markdown": "`SSL_CTX_set_security_level`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.Protocol.TLS.Hard-Coded"
            ]
          }
        },
        {
          "ruleId": "91e098d2-dc87-3d58-8be3-a7c4f2f5ba32",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Win32 - Hard-coded SSL/TLS Protocol"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/tls/openssl.cc"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 5,
                  "endLine": 51,
                  "endColumn": 31,
                  "charOffset": 1436,
                  "charLength": 26,
                  "snippet": {
                    "text": "SSL_CTX_set_security_level",
                    "rendered": {
                      "text": "SSL_CTX_set_security_level",
                      "markdown": "`SSL_CTX_set_security_level`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.Protocol.TLS.Hard-Coded"
            ]
          }
        },
        {
          "ruleId": "7f452c7a-5ed1-3695-9b0b-0da17a39298d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Win32 - Hard-coded SSL/TLS Protocol"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/tls/openssl.cc"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 11,
                  "endLine": 34,
                  "endColumn": 22,
                  "charOffset": 996,
                  "charLength": 11,
                  "snippet": {
                    "text": "SSL_CTX_new",
                    "rendered": {
                      "text": "SSL_CTX_new",
                      "markdown": "`SSL_CTX_new`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.Protocol.TLS.Hard-Coded"
            ]
          }
        },
        {
          "ruleId": "3f09ed87-c388-333a-b01d-4e208594f381",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Win32 - Hard-coded SSL/TLS Protocol"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/tls/openssl.cc"
                },
                "region": {
                  "startLine": 33,
                  "startColumn": 9,
                  "endLine": 33,
                  "endColumn": 20,
                  "charOffset": 945,
                  "charLength": 11,
                  "snippet": {
                    "text": "SSL_CTX_new",
                    "rendered": {
                      "text": "SSL_CTX_new",
                      "markdown": "`SSL_CTX_new`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.Protocol.TLS.Hard-Coded"
            ]
          }
        },
        {
          "ruleId": "32b564e7-93ac-3290-a37e-99cb48d51ec8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/rendezvous/file_store.cc"
                },
                "region": {
                  "startLine": 90,
                  "startColumn": 37,
                  "endLine": 90,
                  "endColumn": 45,
                  "charOffset": 2405,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "d10ec77e-e94e-3bec-9984-e0c21d028e5c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/tls/pair.cc"
                },
                "region": {
                  "startLine": 262,
                  "startColumn": 45,
                  "endLine": 262,
                  "endColumn": 53,
                  "charOffset": 7097,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "60ae94fd-867d-3097-b5e0-5f0d88aafa4b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/tls/pair.cc"
                },
                "region": {
                  "startLine": 175,
                  "startColumn": 26,
                  "endLine": 175,
                  "endColumn": 34,
                  "charOffset": 4497,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "9c81a934-9274-35e2-b307-e5c625e3cee4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/uv/address.cc"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 15,
                  "endLine": 72,
                  "endColumn": 26,
                  "charOffset": 1785,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(str)",
                    "rendered": {
                      "text": "strlen(str)",
                      "markdown": "`strlen(str)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/uv/address.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1785,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(str, <size of str>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/uv/address.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1785,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(str, <size of str>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "55ef0220-6f55-35f7-8299-11461aff53cd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Win32 - Hard-coded SSL/TLS Protocol"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/tls/context.cc"
                },
                "region": {
                  "startLine": 91,
                  "startColumn": 12,
                  "endLine": 91,
                  "endColumn": 38,
                  "charOffset": 3456,
                  "charLength": 26,
                  "snippet": {
                    "text": "SSL_CTX_set_security_level",
                    "rendered": {
                      "text": "SSL_CTX_set_security_level",
                      "markdown": "`SSL_CTX_set_security_level`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.Protocol.TLS.Hard-Coded"
            ]
          }
        },
        {
          "ruleId": "bddc718a-4604-37ca-8b48-ea9fcaa9c3c3",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/rendezvous/file_store.cc"
                },
                "region": {
                  "startLine": 47,
                  "startColumn": 49,
                  "endLine": 47,
                  "endColumn": 57,
                  "charOffset": 1044,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "1eeccbf6-ad54-366a-88b3-0eaa69aa73d1",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "OpenSSL: Do not hardcode SSL/TLS versions within an application."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/tls/context.cc"
                },
                "region": {
                  "startLine": 70,
                  "startColumn": 43,
                  "endLine": 70,
                  "endColumn": 71,
                  "charOffset": 2548,
                  "charLength": 28,
                  "snippet": {
                    "text": "SSL_OP_LEGACY_SERVER_CONNECT",
                    "rendered": {
                      "text": "SSL_OP_LEGACY_SERVER_CONNECT",
                      "markdown": "`SSL_OP_LEGACY_SERVER_CONNECT`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.Protocol.TLS.Hardcoded"
            ]
          }
        },
        {
          "ruleId": "b8946a09-890f-3f81-b801-1d74ff8a3bfd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Win32 - Hard-coded SSL/TLS Protocol"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/tls/context.cc"
                },
                "region": {
                  "startLine": 65,
                  "startColumn": 16,
                  "endLine": 65,
                  "endColumn": 45,
                  "charOffset": 2313,
                  "charLength": 29,
                  "snippet": {
                    "text": "SSL_CTX_set_min_proto_version",
                    "rendered": {
                      "text": "SSL_CTX_set_min_proto_version",
                      "markdown": "`SSL_CTX_set_min_proto_version`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.Protocol.TLS.Hard-Coded"
            ]
          }
        },
        {
          "ruleId": "2c388ac3-2043-37e1-bbf4-c45099d777bf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/uv/address.cc"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 2,
                  "endLine": 28,
                  "endColumn": 44,
                  "charOffset": 598,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(&impl_, bytes.data(), sizeof(impl_)",
                    "rendered": {
                      "text": "memcpy(&impl_, bytes.data(), sizeof(impl_)",
                      "markdown": "`memcpy(&impl_, bytes.data(), sizeof(impl_)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/uv/address.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 598,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&impl_, <size of &impl_>,  bytes.data(),  sizeof(impl_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1f9f821c-e4b5-33c2-9bf2-09a7a880046e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/uv/address.cc"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 2,
                  "endLine": 37,
                  "endColumn": 44,
                  "charOffset": 863,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(bytes.data(), &impl_, sizeof(impl_)",
                    "rendered": {
                      "text": "memcpy(bytes.data(), &impl_, sizeof(impl_)",
                      "markdown": "`memcpy(bytes.data(), &impl_, sizeof(impl_)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/uv/address.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 863,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(bytes.data(), <size of bytes.data()>,  &impl_,  sizeof(impl_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ead99fcb-877b-30a8-acdd-70a6b681c402",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/allgatherv.cc"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 6,
                  "endLine": 110,
                  "endColumn": 19,
                  "charOffset": 3465,
                  "charLength": 141,
                  "snippet": {
                    "text": "memcpy(\n          static_cast<uint8_t*>(out->ptr) + byteOffsets[context->rank],\n          static_cast<uint8_t*>(in->ptr),\n          in->size)",
                    "rendered": {
                      "text": "memcpy(\n          static_cast<uint8_t*>(out->ptr) + byteOffsets[context->rank],\n          static_cast<uint8_t*>(in->ptr),\n          in->size)",
                      "markdown": "`memcpy(\n          static_cast<uint8_t*>(out->ptr) + byteOffsets[context->rank],\n          static_cast<uint8_t*>(in->ptr),\n          in->size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/allgatherv.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3465,
                        "charLength": 141
                      },
                      "insertedContent": {
                        "text": "memcpy_s(\n          static_cast<uint8_t*>(out->ptr) + byteOffsets[context->rank], <size of \n          static_cast<uint8_t*>(out->ptr) + byteOffsets[context->rank]>, \n          static_cast<uint8_t*>(in->ptr), \n          in->size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "be04ce1f-30aa-323d-a6c2-9c18527d80f7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/uv/device.cc"
                },
                "region": {
                  "startLine": 142,
                  "startColumn": 4,
                  "endLine": 142,
                  "endColumn": 54,
                  "charOffset": 3362,
                  "charLength": 50,
                  "snippet": {
                    "text": "memcpy(&attr.ai_addr, rp->ai_addr, rp->ai_addrlen)",
                    "rendered": {
                      "text": "memcpy(&attr.ai_addr, rp->ai_addr, rp->ai_addrlen)",
                      "markdown": "`memcpy(&attr.ai_addr, rp->ai_addr, rp->ai_addrlen)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/uv/device.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3362,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&attr.ai_addr, <size of &attr.ai_addr>,  rp->ai_addr,  rp->ai_addrlen)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f48a3879-2d76-3904-93b7-b80317f0aa7c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/uv/device.cc"
                },
                "region": {
                  "startLine": 89,
                  "startColumn": 8,
                  "endLine": 89,
                  "endColumn": 74,
                  "charOffset": 2038,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(&attr->ai_addr, &address.address4, sizeof(address.address4)",
                    "rendered": {
                      "text": "memcpy(&attr->ai_addr, &address.address4, sizeof(address.address4)",
                      "markdown": "`memcpy(&attr->ai_addr, &address.address4, sizeof(address.address4)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/uv/device.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2038,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&attr->ai_addr, <size of &attr->ai_addr>,  &address.address4,  sizeof(address.address4)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "99b5bbb1-0972-39b7-a50a-ca1db3c91146",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/uv/device.cc"
                },
                "region": {
                  "startLine": 96,
                  "startColumn": 8,
                  "endLine": 96,
                  "endColumn": 74,
                  "charOffset": 2309,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(&attr->ai_addr, &address.address6, sizeof(address.address6)",
                    "rendered": {
                      "text": "memcpy(&attr->ai_addr, &address.address6, sizeof(address.address6)",
                      "markdown": "`memcpy(&attr->ai_addr, &address.address6, sizeof(address.address6)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/uv/device.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2309,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&attr->ai_addr, <size of &attr->ai_addr>,  &address.address6,  sizeof(address.address6)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e3324a69-f358-32b9-a9e4-5d1091d390b7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/alltoallv.cc"
                },
                "region": {
                  "startLine": 142,
                  "startColumn": 2,
                  "endLine": 145,
                  "endColumn": 18,
                  "charOffset": 4678,
                  "charLength": 124,
                  "snippet": {
                    "text": "memcpy(\n      static_cast<char*>(out->ptr) + myOutOffset,\n      static_cast<char*>(in->ptr) + myInOffset,\n      myChunkSize)",
                    "rendered": {
                      "text": "memcpy(\n      static_cast<char*>(out->ptr) + myOutOffset,\n      static_cast<char*>(in->ptr) + myInOffset,\n      myChunkSize)",
                      "markdown": "`memcpy(\n      static_cast<char*>(out->ptr) + myOutOffset,\n      static_cast<char*>(in->ptr) + myInOffset,\n      myChunkSize)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/alltoallv.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4678,
                        "charLength": 124
                      },
                      "insertedContent": {
                        "text": "memcpy_s(\n      static_cast<char*>(out->ptr) + myOutOffset, <size of \n      static_cast<char*>(out->ptr) + myOutOffset>, \n      static_cast<char*>(in->ptr) + myInOffset, \n      myChunkSize)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "5b9d4dc7-d487-32d6-afbc-c67162d0f5aa",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/ibverbs/device.cc"
                },
                "region": {
                  "startLine": 116,
                  "startColumn": 45,
                  "endLine": 116,
                  "endColumn": 53,
                  "charOffset": 2867,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "e990d1b0-94b0-3314-bbc6-547842df8848",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/ibverbs/device.cc"
                },
                "region": {
                  "startLine": 112,
                  "startColumn": 47,
                  "endLine": 112,
                  "endColumn": 55,
                  "charOffset": 2709,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "2b40bb5d-1968-3b6a-8a40-8205f153de55",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/allreduce_ring.h"
                },
                "region": {
                  "startLine": 111,
                  "startColumn": 6,
                  "endLine": 111,
                  "endColumn": 40,
                  "charOffset": 3014,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                    "rendered": {
                      "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                      "markdown": "`memcpy(ptrs_[i], ptrs_[0], bytes_)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/allreduce_ring.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3014,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptrs_[i], <size of ptrs_[i]>,  ptrs_[0],  bytes_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6c86517b-7edb-3fc1-b7cd-cd26cf5b2d5d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/uv/libuv.h"
                },
                "region": {
                  "startLine": 638,
                  "startColumn": 9,
                  "endLine": 638,
                  "endColumn": 41,
                  "charOffset": 15723,
                  "charLength": 32,
                  "snippet": {
                    "text": "memcpy(data.get(), &t, sizeof(T)",
                    "rendered": {
                      "text": "memcpy(data.get(), &t, sizeof(T)",
                      "markdown": "`memcpy(data.get(), &t, sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/uv/libuv.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15723,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "memcpy_s(data.get(), <size of data.get()>,  &t,  sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "65e652d8-a70b-399d-8aa8-6532ada9c672",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/allreduce_ring.h"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 8,
                  "endLine": 98,
                  "endColumn": 39,
                  "charOffset": 2657,
                  "charLength": 31,
                  "snippet": {
                    "text": "memcpy(outbox_, inbox_, bytes_)",
                    "rendered": {
                      "text": "memcpy(outbox_, inbox_, bytes_)",
                      "markdown": "`memcpy(outbox_, inbox_, bytes_)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/allreduce_ring.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2657,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "memcpy_s(outbox_, <size of outbox_>,  inbox_,  bytes_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "4a839d0b-8d38-3b17-9084-483267e3781c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/allreduce_ring.h"
                },
                "region": {
                  "startLine": 80,
                  "startColumn": 4,
                  "endLine": 80,
                  "endColumn": 37,
                  "charOffset": 2129,
                  "charLength": 33,
                  "snippet": {
                    "text": "memcpy(outbox_, ptrs_[0], bytes_)",
                    "rendered": {
                      "text": "memcpy(outbox_, ptrs_[0], bytes_)",
                      "markdown": "`memcpy(outbox_, ptrs_[0], bytes_)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/allreduce_ring.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2129,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "memcpy_s(outbox_, <size of outbox_>,  ptrs_[0],  bytes_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "747b0f17-b737-3655-b140-dd9042a2a08a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/allreduce.cc"
                },
                "region": {
                  "startLine": 89,
                  "startColumn": 6,
                  "endLine": 92,
                  "endColumn": 17,
                  "charOffset": 3041,
                  "charLength": 141,
                  "snippet": {
                    "text": "memcpy(\n          static_cast<uint8_t*>(out[i]->ptr) + offset,\n          static_cast<const uint8_t*>(out[0]->ptr) + offset,\n          length)",
                    "rendered": {
                      "text": "memcpy(\n          static_cast<uint8_t*>(out[i]->ptr) + offset,\n          static_cast<const uint8_t*>(out[0]->ptr) + offset,\n          length)",
                      "markdown": "`memcpy(\n          static_cast<uint8_t*>(out[i]->ptr) + offset,\n          static_cast<const uint8_t*>(out[0]->ptr) + offset,\n          length)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/allreduce.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3041,
                        "charLength": 141
                      },
                      "insertedContent": {
                        "text": "memcpy_s(\n          static_cast<uint8_t*>(out[i]->ptr) + offset, <size of \n          static_cast<uint8_t*>(out[i]->ptr) + offset>, \n          static_cast<const uint8_t*>(out[0]->ptr) + offset, \n          length)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a7f3d54b-4233-37e4-b03c-38cd2d7c9448",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/allreduce.cc"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 8,
                  "endLine": 55,
                  "endColumn": 19,
                  "charOffset": 1584,
                  "charLength": 146,
                  "snippet": {
                    "text": "memcpy(\n            static_cast<uint8_t*>(out[0]->ptr) + offset,\n            static_cast<const uint8_t*>(in[0]->ptr) + offset,\n            length)",
                    "rendered": {
                      "text": "memcpy(\n            static_cast<uint8_t*>(out[0]->ptr) + offset,\n            static_cast<const uint8_t*>(in[0]->ptr) + offset,\n            length)",
                      "markdown": "`memcpy(\n            static_cast<uint8_t*>(out[0]->ptr) + offset,\n            static_cast<const uint8_t*>(in[0]->ptr) + offset,\n            length)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/allreduce.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1584,
                        "charLength": 146
                      },
                      "insertedContent": {
                        "text": "memcpy_s(\n            static_cast<uint8_t*>(out[0]->ptr) + offset, <size of \n            static_cast<uint8_t*>(out[0]->ptr) + offset>, \n            static_cast<const uint8_t*>(in[0]->ptr) + offset, \n            length)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e835e09a-adbf-30b4-86ee-6d8ed836cce5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/mpi/context.cc"
                },
                "region": {
                  "startLine": 143,
                  "startColumn": 4,
                  "endLine": 143,
                  "endColumn": 58,
                  "charOffset": 3773,
                  "charLength": 54,
                  "snippet": {
                    "text": "memcpy(address.data(), out.data() + offset, maxLength)",
                    "rendered": {
                      "text": "memcpy(address.data(), out.data() + offset, maxLength)",
                      "markdown": "`memcpy(address.data(), out.data() + offset, maxLength)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/mpi/context.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3773,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "memcpy_s(address.data(), <size of address.data()>,  out.data() + offset,  maxLength)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1d58d372-6232-3ff1-b0a4-fa784a1e3558",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/mpi/context.cc"
                },
                "region": {
                  "startLine": 125,
                  "startColumn": 4,
                  "endLine": 125,
                  "endColumn": 70,
                  "charOffset": 3265,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(in.data() + (i * maxLength), address.data(), address.size()",
                    "rendered": {
                      "text": "memcpy(in.data() + (i * maxLength), address.data(), address.size()",
                      "markdown": "`memcpy(in.data() + (i * maxLength), address.data(), address.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/mpi/context.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3265,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(in.data() + (i * maxLength), <size of in.data() + (i * maxLength)>,  address.data(),  address.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "9d10efac-857c-3038-b157-da0b4779f409",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Non-Cryptographic or Weak Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/ibverbs/pair.cc"
                },
                "region": {
                  "startLine": 101,
                  "startColumn": 22,
                  "endLine": 101,
                  "endColumn": 27,
                  "charOffset": 2918,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "32c68edd-8bdd-38af-bac6-bb47cce4eec6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/allreduce_bcube.h"
                },
                "region": {
                  "startLine": 350,
                  "startColumn": 8,
                  "endLine": 350,
                  "endColumn": 42,
                  "charOffset": 12135,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                    "rendered": {
                      "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                      "markdown": "`memcpy(ptrs_[i], ptrs_[0], bytes_)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/allreduce_bcube.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12135,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptrs_[i], <size of ptrs_[i]>,  ptrs_[0],  bytes_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "796c26a7-c265-3a6b-aff6-b75f8ef423b6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Production Debug Code Presence\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/mpi/example/main_unmanaged.cc"
                },
                "region": {
                  "startLine": 23,
                  "startColumn": 49,
                  "endLine": 23,
                  "endColumn": 58,
                  "charOffset": 561,
                  "charLength": 9,
                  "snippet": {
                    "text": "localhost",
                    "rendered": {
                      "text": "localhost",
                      "markdown": "`localhost`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Hygiene.Network.AccessingLocalhost"
            ]
          }
        },
        {
          "ruleId": "e74731a3-1100-3620-890c-049fcc560564",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/allreduce_bcube.h"
                },
                "region": {
                  "startLine": 423,
                  "startColumn": 6,
                  "endLine": 423,
                  "endColumn": 40,
                  "charOffset": 14800,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                    "rendered": {
                      "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                      "markdown": "`memcpy(ptrs_[i], ptrs_[0], bytes_)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/allreduce_bcube.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14800,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptrs_[i], <size of ptrs_[i]>,  ptrs_[0],  bytes_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a3ae97a0-d037-3150-b643-6e08ea17a265",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/allreduce_bcube.h"
                },
                "region": {
                  "startLine": 405,
                  "startColumn": 13,
                  "endLine": 408,
                  "endColumn": 33,
                  "charOffset": 14249,
                  "charLength": 124,
                  "snippet": {
                    "text": "memcpy(\n            &ptrs_[0][ptrOffset],\n            &recvBufs_[recvBufIdx_[srcRank]][0],\n            recvCount * sizeof(T)",
                    "rendered": {
                      "text": "memcpy(\n            &ptrs_[0][ptrOffset],\n            &recvBufs_[recvBufIdx_[srcRank]][0],\n            recvCount * sizeof(T)",
                      "markdown": "`memcpy(\n            &ptrs_[0][ptrOffset],\n            &recvBufs_[recvBufIdx_[srcRank]][0],\n            recvCount * sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/allreduce_bcube.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14249,
                        "charLength": 124
                      },
                      "insertedContent": {
                        "text": "memcpy_s(\n            &ptrs_[0][ptrOffset], <size of \n            &ptrs_[0][ptrOffset]>, \n            &recvBufs_[recvBufIdx_[srcRank]][0], \n            recvCount * sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "147e01b3-93eb-3b70-a88c-e17130c827c2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Production Debug Code Presence\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/mpi/example/main_managed.cc"
                },
                "region": {
                  "startLine": 18,
                  "startColumn": 49,
                  "endLine": 18,
                  "endColumn": 58,
                  "charOffset": 497,
                  "charLength": 9,
                  "snippet": {
                    "text": "localhost",
                    "rendered": {
                      "text": "localhost",
                      "markdown": "`localhost`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Hygiene.Network.AccessingLocalhost"
            ]
          }
        },
        {
          "ruleId": "eede7331-8419-3259-a8f7-191a3218c5dd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/gather.cc"
                },
                "region": {
                  "startLine": 44,
                  "startColumn": 4,
                  "endLine": 47,
                  "endColumn": 18,
                  "charOffset": 1141,
                  "charLength": 111,
                  "snippet": {
                    "text": "memcpy(\n        static_cast<char*>(out->ptr) + (context->rank * chunkSize),\n        in->ptr,\n        chunkSize)",
                    "rendered": {
                      "text": "memcpy(\n        static_cast<char*>(out->ptr) + (context->rank * chunkSize),\n        in->ptr,\n        chunkSize)",
                      "markdown": "`memcpy(\n        static_cast<char*>(out->ptr) + (context->rank * chunkSize),\n        in->ptr,\n        chunkSize)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/gather.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1141,
                        "charLength": 111
                      },
                      "insertedContent": {
                        "text": "memcpy_s(\n        static_cast<char*>(out->ptr) + (context->rank * chunkSize), <size of \n        static_cast<char*>(out->ptr) + (context->rank * chunkSize)>, \n        in->ptr, \n        chunkSize)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ab8825d0-704c-377a-9746-7767c4fa5acf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/allgather_ring.h"
                },
                "region": {
                  "startLine": 63,
                  "startColumn": 6,
                  "endLine": 63,
                  "endColumn": 76,
                  "charOffset": 1999,
                  "charLength": 70,
                  "snippet": {
                    "text": "memcpy(outPtr_ + rank * inputStride_ + i * count_, inPtrs_[i], bytes_)",
                    "rendered": {
                      "text": "memcpy(outPtr_ + rank * inputStride_ + i * count_, inPtrs_[i], bytes_)",
                      "markdown": "`memcpy(outPtr_ + rank * inputStride_ + i * count_, inPtrs_[i], bytes_)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/allgather_ring.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1999,
                        "charLength": 70
                      },
                      "insertedContent": {
                        "text": "memcpy_s(outPtr_ + rank * inputStride_ + i * count_, <size of outPtr_ + rank * inputStride_ + i * count_>,  inPtrs_[i],  bytes_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "502524ae-2967-3866-a3de-e61cff565aea",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/address.cc"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 43,
                  "endLine": 107,
                  "endColumn": 51,
                  "charOffset": 2805,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "925eacb8-64c8-347c-8b89-09c6c3d4ccf8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/address.cc"
                },
                "region": {
                  "startLine": 97,
                  "startColumn": 43,
                  "endLine": 97,
                  "endColumn": 51,
                  "charOffset": 2547,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "2a9155fa-0910-3e85-9ee8-c10809a0f46e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/address.cc"
                },
                "region": {
                  "startLine": 76,
                  "startColumn": 15,
                  "endLine": 76,
                  "endColumn": 26,
                  "charOffset": 1986,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(str)",
                    "rendered": {
                      "text": "strlen(str)",
                      "markdown": "`strlen(str)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/tcp/address.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1986,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(str, <size of str>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/tcp/address.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1986,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(str, <size of str>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "cba32b7f-4d97-34c0-8169-ceab94ddba9a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/address.cc"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 2,
                  "endLine": 55,
                  "endColumn": 44,
                  "charOffset": 1343,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(bytes.data(), &impl_, sizeof(impl_)",
                    "rendered": {
                      "text": "memcpy(bytes.data(), &impl_, sizeof(impl_)",
                      "markdown": "`memcpy(bytes.data(), &impl_, sizeof(impl_)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/tcp/address.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1343,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(bytes.data(), <size of bytes.data()>,  &impl_,  sizeof(impl_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "84c31292-7681-3f25-b444-13ca03b04444",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/address.cc"
                },
                "region": {
                  "startLine": 46,
                  "startColumn": 2,
                  "endLine": 46,
                  "endColumn": 44,
                  "charOffset": 1078,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(&impl_, bytes.data(), sizeof(impl_)",
                    "rendered": {
                      "text": "memcpy(&impl_, bytes.data(), sizeof(impl_)",
                      "markdown": "`memcpy(&impl_, bytes.data(), sizeof(impl_)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/tcp/address.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1078,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&impl_, <size of &impl_>,  bytes.data(),  sizeof(impl_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2964b590-e367-3b83-bf0b-0ef6a7ba8892",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/address.cc"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 2,
                  "endLine": 27,
                  "endColumn": 34,
                  "charOffset": 592,
                  "charLength": 32,
                  "snippet": {
                    "text": "memcpy(&impl_.ss, addr, addrlen)",
                    "rendered": {
                      "text": "memcpy(&impl_.ss, addr, addrlen)",
                      "markdown": "`memcpy(&impl_.ss, addr, addrlen)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/tcp/address.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 592,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&impl_.ss, <size of &impl_.ss>,  addr,  addrlen)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0218fb85-96b2-3ce6-b9f5-d39d55ddb8ad",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/allgather.cc"
                },
                "region": {
                  "startLine": 50,
                  "startColumn": 4,
                  "endLine": 53,
                  "endColumn": 17,
                  "charOffset": 1654,
                  "charLength": 133,
                  "snippet": {
                    "text": "memcpy(\n        static_cast<uint8_t*>(out->ptr) + context->rank * in->size,\n        static_cast<uint8_t*>(in->ptr),\n        in->size)",
                    "rendered": {
                      "text": "memcpy(\n        static_cast<uint8_t*>(out->ptr) + context->rank * in->size,\n        static_cast<uint8_t*>(in->ptr),\n        in->size)",
                      "markdown": "`memcpy(\n        static_cast<uint8_t*>(out->ptr) + context->rank * in->size,\n        static_cast<uint8_t*>(in->ptr),\n        in->size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/allgather.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1654,
                        "charLength": 133
                      },
                      "insertedContent": {
                        "text": "memcpy_s(\n        static_cast<uint8_t*>(out->ptr) + context->rank * in->size, <size of \n        static_cast<uint8_t*>(out->ptr) + context->rank * in->size>, \n        static_cast<uint8_t*>(in->ptr), \n        in->size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3e0a80e5-ee0c-3529-b531-c68c8cfb1129",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/common/linux.cc"
                },
                "region": {
                  "startLine": 255,
                  "startColumn": 2,
                  "endLine": 255,
                  "endColumn": 43,
                  "charOffset": 6233,
                  "charLength": 41,
                  "snippet": {
                    "text": "memcpy(ifr.ifr_name, ifname.c_str(), len)",
                    "rendered": {
                      "text": "memcpy(ifr.ifr_name, ifname.c_str(), len)",
                      "markdown": "`memcpy(ifr.ifr_name, ifname.c_str(), len)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/common/linux.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6233,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ifr.ifr_name, <size of ifr.ifr_name>,  ifname.c_str(),  len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "75d86a64-ff64-3127-a451-b7688bf6e570",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/common/linux.cc"
                },
                "region": {
                  "startLine": 111,
                  "startColumn": 26,
                  "endLine": 111,
                  "endColumn": 34,
                  "charOffset": 2762,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "84006356-71b7-3f12-a6b2-dfad6f6b8138",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/common/linux.cc"
                },
                "region": {
                  "startLine": 80,
                  "startColumn": 24,
                  "endLine": 80,
                  "endColumn": 32,
                  "charOffset": 1918,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "16f591ef-f299-3a9e-ab98-034d43c84147",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/common/linux.cc"
                },
                "region": {
                  "startLine": 78,
                  "startColumn": 27,
                  "endLine": 78,
                  "endColumn": 35,
                  "charOffset": 1848,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "95f6c508-b5ea-3de6-b467-ac6c79ba8c79",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/common/linux.cc"
                },
                "region": {
                  "startLine": 70,
                  "startColumn": 32,
                  "endLine": 70,
                  "endColumn": 40,
                  "charOffset": 1642,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "f60acd9d-4143-3a24-950e-f6b52ede8016",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/allreduce_local.cc"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 4,
                  "endLine": 36,
                  "endColumn": 38,
                  "charOffset": 859,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                    "rendered": {
                      "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                      "markdown": "`memcpy(ptrs_[i], ptrs_[0], bytes_)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/allreduce_local.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 859,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptrs_[i], <size of ptrs_[i]>,  ptrs_[0],  bytes_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "484d3575-2f87-3dcc-84e1-8c128bb3c7d8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/device.cc"
                },
                "region": {
                  "startLine": 183,
                  "startColumn": 26,
                  "endLine": 183,
                  "endColumn": 34,
                  "charOffset": 5142,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "91199611-014a-3faf-bf9b-e0f43f77a6a7",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/device.cc"
                },
                "region": {
                  "startLine": 133,
                  "startColumn": 4,
                  "endLine": 133,
                  "endColumn": 12,
                  "charOffset": 3604,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4669bc03-2809-3a3b-96bc-a6a045fb9e3c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/device.cc"
                },
                "region": {
                  "startLine": 119,
                  "startColumn": 4,
                  "endLine": 119,
                  "endColumn": 54,
                  "charOffset": 3267,
                  "charLength": 50,
                  "snippet": {
                    "text": "memcpy(&attr.ai_addr, rp->ai_addr, rp->ai_addrlen)",
                    "rendered": {
                      "text": "memcpy(&attr.ai_addr, rp->ai_addr, rp->ai_addrlen)",
                      "markdown": "`memcpy(&attr.ai_addr, rp->ai_addr, rp->ai_addrlen)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/tcp/device.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3267,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&attr.ai_addr, <size of &attr.ai_addr>,  rp->ai_addr,  rp->ai_addrlen)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c04123ce-49c4-30c1-8a74-1c270ccefdc7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/device.cc"
                },
                "region": {
                  "startLine": 71,
                  "startColumn": 8,
                  "endLine": 71,
                  "endColumn": 61,
                  "charOffset": 1994,
                  "charLength": 53,
                  "snippet": {
                    "text": "memcpy(&attr.ai_addr, ifa->ifa_addr, attr.ai_addrlen)",
                    "rendered": {
                      "text": "memcpy(&attr.ai_addr, ifa->ifa_addr, attr.ai_addrlen)",
                      "markdown": "`memcpy(&attr.ai_addr, ifa->ifa_addr, attr.ai_addrlen)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/tcp/device.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1994,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&attr.ai_addr, <size of &attr.ai_addr>,  ifa->ifa_addr,  attr.ai_addrlen)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "cbbb9097-eeac-381b-8aca-af1ab01330f7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/device.cc"
                },
                "region": {
                  "startLine": 56,
                  "startColumn": 8,
                  "endLine": 56,
                  "endColumn": 61,
                  "charOffset": 1518,
                  "charLength": 53,
                  "snippet": {
                    "text": "memcpy(&attr.ai_addr, ifa->ifa_addr, attr.ai_addrlen)",
                    "rendered": {
                      "text": "memcpy(&attr.ai_addr, ifa->ifa_addr, attr.ai_addrlen)",
                      "markdown": "`memcpy(&attr.ai_addr, ifa->ifa_addr, attr.ai_addrlen)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/tcp/device.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1518,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&attr.ai_addr, <size of &attr.ai_addr>,  ifa->ifa_addr,  attr.ai_addrlen)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "887de324-11b9-3d76-b5ae-8d3cbc594548",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/device.cc"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 8,
                  "endLine": 49,
                  "endColumn": 61,
                  "charOffset": 1282,
                  "charLength": 53,
                  "snippet": {
                    "text": "memcpy(&attr.ai_addr, ifa->ifa_addr, attr.ai_addrlen)",
                    "rendered": {
                      "text": "memcpy(&attr.ai_addr, ifa->ifa_addr, attr.ai_addrlen)",
                      "markdown": "`memcpy(&attr.ai_addr, ifa->ifa_addr, attr.ai_addrlen)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/tcp/device.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1282,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&attr.ai_addr, <size of &attr.ai_addr>,  ifa->ifa_addr,  attr.ai_addrlen)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f6c4835d-7939-3d47-a95b-0bf2b378d2f2",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/device.cc"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 26,
                  "endLine": 31,
                  "endColumn": 34,
                  "charOffset": 719,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "e7ce36cb-52aa-3534-ac0c-f07a093e4fc2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/reduce.cc"
                },
                "region": {
                  "startLine": 56,
                  "startColumn": 6,
                  "endLine": 56,
                  "endColumn": 65,
                  "charOffset": 1777,
                  "charLength": 59,
                  "snippet": {
                    "text": "memcpy(out->ptr, in->ptr, opts.elements * opts.elementSize)",
                    "rendered": {
                      "text": "memcpy(out->ptr, in->ptr, opts.elements * opts.elementSize)",
                      "markdown": "`memcpy(out->ptr, in->ptr, opts.elements * opts.elementSize)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/reduce.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1777,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out->ptr, <size of out->ptr>,  in->ptr,  opts.elements * opts.elementSize)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ec005ff6-7e92-366d-b865-51282adf062a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/allreduce_ring_chunked.h"
                },
                "region": {
                  "startLine": 210,
                  "startColumn": 6,
                  "endLine": 210,
                  "endColumn": 40,
                  "charOffset": 6946,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                    "rendered": {
                      "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                      "markdown": "`memcpy(ptrs_[i], ptrs_[0], bytes_)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/allreduce_ring_chunked.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6946,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptrs_[i], <size of ptrs_[i]>,  ptrs_[0],  bytes_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "70fb2565-7708-3f75-90cc-bd0da2a734fc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/allreduce_ring_chunked.h"
                },
                "region": {
                  "startLine": 184,
                  "startColumn": 8,
                  "endLine": 184,
                  "endColumn": 77,
                  "charOffset": 6071,
                  "charLength": 69,
                  "snippet": {
                    "text": "memcpy(&ptrs_[0][offset], inbox_[chunkOffset & 1], length * sizeof(T)",
                    "rendered": {
                      "text": "memcpy(&ptrs_[0][offset], inbox_[chunkOffset & 1], length * sizeof(T)",
                      "markdown": "`memcpy(&ptrs_[0][offset], inbox_[chunkOffset & 1], length * sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/allreduce_ring_chunked.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6071,
                        "charLength": 69
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&ptrs_[0][offset], <size of &ptrs_[0][offset]>,  inbox_[chunkOffset & 1],  length * sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "03e0fab1-b339-3b6d-8a5a-0eb97d3704e8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/allreduce_ring_chunked.h"
                },
                "region": {
                  "startLine": 96,
                  "startColumn": 8,
                  "endLine": 96,
                  "endColumn": 42,
                  "charOffset": 2696,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                    "rendered": {
                      "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                      "markdown": "`memcpy(ptrs_[i], ptrs_[0], bytes_)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/allreduce_ring_chunked.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2696,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptrs_[i], <size of ptrs_[i]>,  ptrs_[0],  bytes_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "9501b3ed-5fd6-38ec-bffc-c4d9a4b1febd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/alltoall.cc"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 2,
                  "endLine": 40,
                  "endColumn": 16,
                  "charOffset": 992,
                  "charLength": 137,
                  "snippet": {
                    "text": "memcpy(\n      static_cast<char*>(out->ptr) + myRank * chunkSize,\n      static_cast<char*>(in->ptr) + myRank * chunkSize,\n      chunkSize)",
                    "rendered": {
                      "text": "memcpy(\n      static_cast<char*>(out->ptr) + myRank * chunkSize,\n      static_cast<char*>(in->ptr) + myRank * chunkSize,\n      chunkSize)",
                      "markdown": "`memcpy(\n      static_cast<char*>(out->ptr) + myRank * chunkSize,\n      static_cast<char*>(in->ptr) + myRank * chunkSize,\n      chunkSize)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/alltoall.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 992,
                        "charLength": 137
                      },
                      "insertedContent": {
                        "text": "memcpy_s(\n      static_cast<char*>(out->ptr) + myRank * chunkSize, <size of \n      static_cast<char*>(out->ptr) + myRank * chunkSize>, \n      static_cast<char*>(in->ptr) + myRank * chunkSize, \n      chunkSize)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "81af8a7a-b52d-311d-9e2a-b2c11d9e9a9d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/gatherv.cc"
                },
                "region": {
                  "startLine": 94,
                  "startColumn": 10,
                  "endLine": 97,
                  "endColumn": 23,
                  "charOffset": 2799,
                  "charLength": 107,
                  "snippet": {
                    "text": "memcpy(\n              static_cast<char*>(out->ptr) + offset,\n              in->ptr,\n              in->size)",
                    "rendered": {
                      "text": "memcpy(\n              static_cast<char*>(out->ptr) + offset,\n              in->ptr,\n              in->size)",
                      "markdown": "`memcpy(\n              static_cast<char*>(out->ptr) + offset,\n              in->ptr,\n              in->size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/gatherv.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2799,
                        "charLength": 107
                      },
                      "insertedContent": {
                        "text": "memcpy_s(\n              static_cast<char*>(out->ptr) + offset, <size of \n              static_cast<char*>(out->ptr) + offset>, \n              in->ptr, \n              in->size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "381bd970-92bd-323f-a7e7-271694942b0e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/pair.cc"
                },
                "region": {
                  "startLine": 799,
                  "startColumn": 54,
                  "endLine": 799,
                  "endColumn": 62,
                  "charOffset": 22727,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "5b00e094-edfe-357c-b47f-652de84cbe24",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/pair.cc"
                },
                "region": {
                  "startLine": 778,
                  "startColumn": 47,
                  "endLine": 778,
                  "endColumn": 55,
                  "charOffset": 22257,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "8ac08341-5db8-35f2-8733-b389f4b676e8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/pair.cc"
                },
                "region": {
                  "startLine": 589,
                  "startColumn": 61,
                  "endLine": 589,
                  "endColumn": 69,
                  "charOffset": 16652,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "b4bd9cde-a788-3ebf-92a7-4a9d2e82495d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/pair.cc"
                },
                "region": {
                  "startLine": 395,
                  "startColumn": 55,
                  "endLine": 395,
                  "endColumn": 63,
                  "charOffset": 10328,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "6b665f15-2f96-3e9c-9ae1-251cbd1bc4a3",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/pair.cc"
                },
                "region": {
                  "startLine": 271,
                  "startColumn": 56,
                  "endLine": 271,
                  "endColumn": 64,
                  "charOffset": 7250,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "fd75822b-078f-325a-bede-4725e9d9e9d8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/pair.cc"
                },
                "region": {
                  "startLine": 263,
                  "startColumn": 59,
                  "endLine": 263,
                  "endColumn": 67,
                  "charOffset": 7006,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "7c6b43d4-d76c-367c-b952-eef692ba8dd3",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/pair.cc"
                },
                "region": {
                  "startLine": 254,
                  "startColumn": 55,
                  "endLine": 254,
                  "endColumn": 63,
                  "charOffset": 6715,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "1335673f-b0fc-3092-b762-9d794e45e49a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/pair.cc"
                },
                "region": {
                  "startLine": 185,
                  "startColumn": 55,
                  "endLine": 185,
                  "endColumn": 63,
                  "charOffset": 4725,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "c101b4f5-a1bc-3fd9-b848-865b5539713d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/pair.cc"
                },
                "region": {
                  "startLine": 176,
                  "startColumn": 53,
                  "endLine": 176,
                  "endColumn": 61,
                  "charOffset": 4526,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "6274f92c-0f62-3b0b-b06f-38daa190c1ec",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/pair.cc"
                },
                "region": {
                  "startLine": 170,
                  "startColumn": 59,
                  "endLine": 170,
                  "endColumn": 67,
                  "charOffset": 4348,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "01432ad5-0c92-36cc-90c5-ed6faab06a4f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/pair.cc"
                },
                "region": {
                  "startLine": 162,
                  "startColumn": 55,
                  "endLine": 162,
                  "endColumn": 63,
                  "charOffset": 4078,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "a48a4caf-3da2-3444-8d76-5adf1ce8b2b5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/cuda_collectives_native.h"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 9,
                  "endLine": 57,
                  "endColumn": 17,
                  "charOffset": 1698,
                  "charLength": 8,
                  "snippet": {
                    "text": "shuffle(",
                    "rendered": {
                      "text": "shuffle(",
                      "markdown": "`shuffle(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "59e42db4-2d9a-39e5-beac-a75a9295cefb",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/examples/example1.cc"
                },
                "region": {
                  "startLine": 93,
                  "startColumn": 23,
                  "endLine": 93,
                  "endColumn": 29,
                  "charOffset": 3199,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "7bd8efbd-de84-36b5-a623-5193aefabbc6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Production Code Debugging Vulnerability\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/examples/example1.cc"
                },
                "region": {
                  "startLine": 71,
                  "startColumn": 54,
                  "endLine": 71,
                  "endColumn": 63,
                  "charOffset": 2256,
                  "charLength": 9,
                  "snippet": {
                    "text": "localhost",
                    "rendered": {
                      "text": "localhost",
                      "markdown": "`localhost`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Hygiene.Network.AccessingLocalhost"
            ]
          }
        },
        {
          "ruleId": "46221b18-05e7-36d8-a988-790924317714",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/examples/example1.cc"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 6,
                  "endLine": 34,
                  "endColumn": 12,
                  "charOffset": 755,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "c3bb4fbe-31cf-35ff-84ca-9d0c2a14884e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/examples/example1.cc"
                },
                "region": {
                  "startLine": 33,
                  "startColumn": 6,
                  "endLine": 33,
                  "endColumn": 12,
                  "charOffset": 720,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "007912d5-8174-3efd-9e02-d0e26291636d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/examples/example1.cc"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 6,
                  "endLine": 32,
                  "endColumn": 12,
                  "charOffset": 683,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "509bee2c-39d6-3d57-a505-a0caaae0f2a9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/reduce_scatter.h"
                },
                "region": {
                  "startLine": 426,
                  "startColumn": 6,
                  "endLine": 426,
                  "endColumn": 40,
                  "charOffset": 15530,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                    "rendered": {
                      "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                      "markdown": "`memcpy(ptrs_[i], ptrs_[0], bytes_)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/reduce_scatter.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15530,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptrs_[i], <size of ptrs_[i]>,  ptrs_[0],  bytes_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "51a6f854-4eda-3126-a242-2ca7da87fde6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/reduce_scatter.h"
                },
                "region": {
                  "startLine": 415,
                  "startColumn": 10,
                  "endLine": 418,
                  "endColumn": 43,
                  "charOffset": 15253,
                  "charLength": 131,
                  "snippet": {
                    "text": "memcpy(\n              &ptrs_[0][bufferOffset],\n              &ptrs_[0][distMap.offset],\n              distMap.itemCount * sizeof(T)",
                    "rendered": {
                      "text": "memcpy(\n              &ptrs_[0][bufferOffset],\n              &ptrs_[0][distMap.offset],\n              distMap.itemCount * sizeof(T)",
                      "markdown": "`memcpy(\n              &ptrs_[0][bufferOffset],\n              &ptrs_[0][distMap.offset],\n              distMap.itemCount * sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/reduce_scatter.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15253,
                        "charLength": 131
                      },
                      "insertedContent": {
                        "text": "memcpy_s(\n              &ptrs_[0][bufferOffset], <size of \n              &ptrs_[0][bufferOffset]>, \n              &ptrs_[0][distMap.offset], \n              distMap.itemCount * sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2111233a-9672-32d6-98a3-3749cb802ae8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/reduce_scatter.h"
                },
                "region": {
                  "startLine": 408,
                  "startColumn": 8,
                  "endLine": 411,
                  "endColumn": 41,
                  "charOffset": 14973,
                  "charLength": 129,
                  "snippet": {
                    "text": "memcpy(\n            &ptrs_[0][bufferOffset],\n            &recvBufDist_[distMap.offset],\n            distMap.itemCount * sizeof(T)",
                    "rendered": {
                      "text": "memcpy(\n            &ptrs_[0][bufferOffset],\n            &recvBufDist_[distMap.offset],\n            distMap.itemCount * sizeof(T)",
                      "markdown": "`memcpy(\n            &ptrs_[0][bufferOffset],\n            &recvBufDist_[distMap.offset],\n            distMap.itemCount * sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/reduce_scatter.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14973,
                        "charLength": 129
                      },
                      "insertedContent": {
                        "text": "memcpy_s(\n            &ptrs_[0][bufferOffset], <size of \n            &ptrs_[0][bufferOffset]>, \n            &recvBufDist_[distMap.offset], \n            distMap.itemCount * sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "36c016b9-1171-35d4-bf56-7839796674ca",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/reduce_scatter.h"
                },
                "region": {
                  "startLine": 333,
                  "startColumn": 8,
                  "endLine": 333,
                  "endColumn": 42,
                  "charOffset": 12310,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                    "rendered": {
                      "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                      "markdown": "`memcpy(ptrs_[i], ptrs_[0], bytes_)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/reduce_scatter.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12310,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptrs_[i], <size of ptrs_[i]>,  ptrs_[0],  bytes_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1e6f321b-8782-32f7-8087-2644ebe3451a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/examples/example_reduce.cc"
                },
                "region": {
                  "startLine": 108,
                  "startColumn": 23,
                  "endLine": 108,
                  "endColumn": 29,
                  "charOffset": 3639,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "bc0923b1-20f9-3ac6-85fb-25f7a319f52f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Production Code Debugging Vulnerability\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/examples/example_reduce.cc"
                },
                "region": {
                  "startLine": 86,
                  "startColumn": 54,
                  "endLine": 86,
                  "endColumn": 63,
                  "charOffset": 2694,
                  "charLength": 9,
                  "snippet": {
                    "text": "localhost",
                    "rendered": {
                      "text": "localhost",
                      "markdown": "`localhost`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Hygiene.Network.AccessingLocalhost"
            ]
          }
        },
        {
          "ruleId": "91918fef-3426-340b-bf88-57441c04ff81",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/examples/example_reduce.cc"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 6,
                  "endLine": 49,
                  "endColumn": 12,
                  "charOffset": 1183,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4ca99c26-89df-3f26-a174-d7308feae32d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/examples/example_reduce.cc"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 6,
                  "endLine": 48,
                  "endColumn": 12,
                  "charOffset": 1148,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "e53c23e8-a230-36ed-8366-572a7ef4f6fe",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/examples/example_reduce.cc"
                },
                "region": {
                  "startLine": 47,
                  "startColumn": 6,
                  "endLine": 47,
                  "endColumn": 12,
                  "charOffset": 1111,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "8481cffe-8839-30f4-9d07-78e4eb668a6e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/allreduce_halving_doubling.h"
                },
                "region": {
                  "startLine": 345,
                  "startColumn": 6,
                  "endLine": 345,
                  "endColumn": 40,
                  "charOffset": 12597,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                    "rendered": {
                      "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                      "markdown": "`memcpy(ptrs_[i], ptrs_[0], bytes_)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/allreduce_halving_doubling.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12597,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptrs_[i], <size of ptrs_[i]>,  ptrs_[0],  bytes_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "bef8a2eb-9ef8-3769-890a-053e9899b797",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/allreduce_halving_doubling.h"
                },
                "region": {
                  "startLine": 331,
                  "startColumn": 8,
                  "endLine": 334,
                  "endColumn": 38,
                  "charOffset": 12197,
                  "charLength": 123,
                  "snippet": {
                    "text": "memcpy(\n            &ptrs_[0][sendOffsets_[i]],\n            &recvBuf_[bufferOffset],\n            sendCounts_[i] * sizeof(T)",
                    "rendered": {
                      "text": "memcpy(\n            &ptrs_[0][sendOffsets_[i]],\n            &recvBuf_[bufferOffset],\n            sendCounts_[i] * sizeof(T)",
                      "markdown": "`memcpy(\n            &ptrs_[0][sendOffsets_[i]],\n            &recvBuf_[bufferOffset],\n            sendCounts_[i] * sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/allreduce_halving_doubling.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12197,
                        "charLength": 123
                      },
                      "insertedContent": {
                        "text": "memcpy_s(\n            &ptrs_[0][sendOffsets_[i]], <size of \n            &ptrs_[0][sendOffsets_[i]]>, \n            &recvBuf_[bufferOffset], \n            sendCounts_[i] * sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a45cf520-4225-335a-9341-f966332789e1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/allreduce_halving_doubling.h"
                },
                "region": {
                  "startLine": 301,
                  "startColumn": 6,
                  "endLine": 304,
                  "endColumn": 38,
                  "charOffset": 11097,
                  "charLength": 110,
                  "snippet": {
                    "text": "memcpy(\n          &ptrs_[0][offset],\n          &recvBuf_[bufferOffset],\n          totalItemsToSend * sizeof(T)",
                    "rendered": {
                      "text": "memcpy(\n          &ptrs_[0][offset],\n          &recvBuf_[bufferOffset],\n          totalItemsToSend * sizeof(T)",
                      "markdown": "`memcpy(\n          &ptrs_[0][offset],\n          &recvBuf_[bufferOffset],\n          totalItemsToSend * sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/allreduce_halving_doubling.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11097,
                        "charLength": 110
                      },
                      "insertedContent": {
                        "text": "memcpy_s(\n          &ptrs_[0][offset], <size of \n          &ptrs_[0][offset]>, \n          &recvBuf_[bufferOffset], \n          totalItemsToSend * sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "74c2f3ea-7d4a-3da8-805b-44932e22bc56",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/allreduce_halving_doubling.h"
                },
                "region": {
                  "startLine": 238,
                  "startColumn": 8,
                  "endLine": 238,
                  "endColumn": 42,
                  "charOffset": 8797,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                    "rendered": {
                      "text": "memcpy(ptrs_[i], ptrs_[0], bytes_)",
                      "markdown": "`memcpy(ptrs_[i], ptrs_[0], bytes_)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/allreduce_halving_doubling.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8797,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptrs_[i], <size of ptrs_[i]>,  ptrs_[0],  bytes_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "55578fe2-3fdd-3444-838c-0d25c14a90a5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/examples/example_allreduce.cc"
                },
                "region": {
                  "startLine": 130,
                  "startColumn": 41,
                  "endLine": 130,
                  "endColumn": 59,
                  "charOffset": 4671,
                  "charLength": 18,
                  "snippet": {
                    "text": "malloc(sizeof(int)",
                    "rendered": {
                      "text": "malloc(sizeof(int)",
                      "markdown": "`malloc(sizeof(int)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/examples/example_allreduce.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4671,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "69a5efe2-c80c-3a59-914e-e79db7e3a27e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/examples/example_allreduce.cc"
                },
                "region": {
                  "startLine": 127,
                  "startColumn": 40,
                  "endLine": 127,
                  "endColumn": 58,
                  "charOffset": 4543,
                  "charLength": 18,
                  "snippet": {
                    "text": "malloc(sizeof(int)",
                    "rendered": {
                      "text": "malloc(sizeof(int)",
                      "markdown": "`malloc(sizeof(int)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/examples/example_allreduce.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4543,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "304bdfce-cdf2-3708-9ca3-0ebd7ce2073b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/examples/example_allreduce.cc"
                },
                "region": {
                  "startLine": 108,
                  "startColumn": 23,
                  "endLine": 108,
                  "endColumn": 29,
                  "charOffset": 3624,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "67416a2b-fd6a-32b6-934b-f35f6e88532f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Production Code Debugging Vulnerability\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/examples/example_allreduce.cc"
                },
                "region": {
                  "startLine": 86,
                  "startColumn": 54,
                  "endLine": 86,
                  "endColumn": 63,
                  "charOffset": 2679,
                  "charLength": 9,
                  "snippet": {
                    "text": "localhost",
                    "rendered": {
                      "text": "localhost",
                      "markdown": "`localhost`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Hygiene.Network.AccessingLocalhost"
            ]
          }
        },
        {
          "ruleId": "13167f9c-f485-3cf5-a9a2-45fa8f21395a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/examples/example_allreduce.cc"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 6,
                  "endLine": 49,
                  "endColumn": 12,
                  "charOffset": 1170,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "c9b40425-0bde-3795-a05b-24ee4f4f1712",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/examples/example_allreduce.cc"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 6,
                  "endLine": 48,
                  "endColumn": 12,
                  "charOffset": 1135,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "24b06255-3b8d-319c-8be3-af2341ed9a3b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/examples/example_allreduce.cc"
                },
                "region": {
                  "startLine": 47,
                  "startColumn": 6,
                  "endLine": 47,
                  "endColumn": 12,
                  "charOffset": 1098,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "beae45ff-f160-3097-b4f3-484ade617825",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/loop.cc"
                },
                "region": {
                  "startLine": 73,
                  "startColumn": 41,
                  "endLine": 73,
                  "endColumn": 49,
                  "charOffset": 1816,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "19572b35-2996-3c12-ad9b-5dfbd5277446",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Production Debug Code Presence\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/examples/looks_like_mpi.cc"
                },
                "region": {
                  "startLine": 199,
                  "startColumn": 49,
                  "endLine": 199,
                  "endColumn": 58,
                  "charOffset": 4735,
                  "charLength": 9,
                  "snippet": {
                    "text": "localhost",
                    "rendered": {
                      "text": "localhost",
                      "markdown": "`localhost`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Hygiene.Network.AccessingLocalhost"
            ]
          }
        },
        {
          "ruleId": "3e3dc112-dcaf-3b74-a4cf-b5adab26662e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/loop.cc"
                },
                "region": {
                  "startLine": 68,
                  "startColumn": 41,
                  "endLine": 68,
                  "endColumn": 49,
                  "charOffset": 1644,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "dec4341d-62fc-34c2-ad1b-b8046dda5d15",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/loop.cc"
                },
                "region": {
                  "startLine": 45,
                  "startColumn": 45,
                  "endLine": 45,
                  "endColumn": 53,
                  "charOffset": 1146,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "5c29cc7a-caa2-3d12-9a30-b9d0e1a63481",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/examples/looks_like_mpi.cc"
                },
                "region": {
                  "startLine": 181,
                  "startColumn": 6,
                  "endLine": 181,
                  "endColumn": 12,
                  "charOffset": 4178,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "698884a4-369f-39e7-a091-19a1f6de3cbd",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/examples/looks_like_mpi.cc"
                },
                "region": {
                  "startLine": 188,
                  "startColumn": 29,
                  "endLine": 188,
                  "endColumn": 35,
                  "charOffset": 4356,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "3011b382-c622-32cb-a083-8502d8de41af",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/examples/looks_like_mpi.cc"
                },
                "region": {
                  "startLine": 180,
                  "startColumn": 6,
                  "endLine": 180,
                  "endColumn": 12,
                  "charOffset": 4143,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "d19b9ac8-87ee-3e18-a4db-ceb17ecd9192",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/examples/looks_like_mpi.cc"
                },
                "region": {
                  "startLine": 179,
                  "startColumn": 6,
                  "endLine": 179,
                  "endColumn": 12,
                  "charOffset": 4106,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "ad39fb49-1598-38e5-b9a1-3ef8ccdc39b4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/broadcast.cc"
                },
                "region": {
                  "startLine": 88,
                  "startColumn": 4,
                  "endLine": 88,
                  "endColumn": 40,
                  "charOffset": 2621,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(out->ptr, in->ptr, out->size)",
                    "rendered": {
                      "text": "memcpy(out->ptr, in->ptr, out->size)",
                      "markdown": "`memcpy(out->ptr, in->ptr, out->size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/broadcast.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2621,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out->ptr, <size of out->ptr>,  in->ptr,  out->size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "76dff85e-37a8-3bc5-9688-4b1650b68c21",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/broadcast_one_to_all.h"
                },
                "region": {
                  "startLine": 110,
                  "startColumn": 6,
                  "endLine": 110,
                  "endColumn": 55,
                  "charOffset": 3097,
                  "charLength": 49,
                  "snippet": {
                    "text": "memcpy(ptrs_[i], ptrs_[rootPointerRank_], bytes_)",
                    "rendered": {
                      "text": "memcpy(ptrs_[i], ptrs_[rootPointerRank_], bytes_)",
                      "markdown": "`memcpy(ptrs_[i], ptrs_[rootPointerRank_], bytes_)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/broadcast_one_to_all.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3097,
                        "charLength": 49
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptrs_[i], <size of ptrs_[i]>,  ptrs_[rootPointerRank_],  bytes_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "4a6c9f7c-8274-3b47-9943-41b33b82a42f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/ibverbs/memory_region.cc"
                },
                "region": {
                  "startLine": 30,
                  "startColumn": 2,
                  "endLine": 30,
                  "endColumn": 33,
                  "charOffset": 745,
                  "charLength": 31,
                  "snippet": {
                    "text": "memcpy(&src_, src, sizeof(src_)",
                    "rendered": {
                      "text": "memcpy(&src_, src, sizeof(src_)",
                      "markdown": "`memcpy(&src_, src, sizeof(src_)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/ibverbs/memory_region.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 745,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&src_, <size of &src_>,  src,  sizeof(src_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3dbeca40-dd7d-3aa6-9fea-8092efc20793",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 361,
                  "startColumn": 16,
                  "endLine": 361,
                  "endColumn": 22,
                  "charOffset": 10827,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "bd9fa479-fb9b-3b10-81fb-7dd0365b71ec",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 344,
                  "startColumn": 44,
                  "endLine": 344,
                  "endColumn": 58,
                  "charOffset": 10528,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(optarg)",
                    "rendered": {
                      "text": "strlen(optarg)",
                      "markdown": "`strlen(optarg)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10528,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10528,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ca63e922-baab-3e7d-995e-2aba08bfabba",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 339,
                  "startColumn": 44,
                  "endLine": 339,
                  "endColumn": 58,
                  "charOffset": 10404,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(optarg)",
                    "rendered": {
                      "text": "strlen(optarg)",
                      "markdown": "`strlen(optarg)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10404,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10404,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f8a85ba7-f1fd-3a88-af26-840e6bd705cb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 334,
                  "startColumn": 42,
                  "endLine": 334,
                  "endColumn": 56,
                  "charOffset": 10280,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(optarg)",
                    "rendered": {
                      "text": "strlen(optarg)",
                      "markdown": "`strlen(optarg)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10280,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10280,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3cd67c0a-f7e1-3559-aa4c-3142d58d532f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 329,
                  "startColumn": 42,
                  "endLine": 329,
                  "endColumn": 56,
                  "charOffset": 10161,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(optarg)",
                    "rendered": {
                      "text": "strlen(optarg)",
                      "markdown": "`strlen(optarg)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10161,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10161,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2df6955a-5f11-3873-bf6a-8941b4726f3f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 324,
                  "startColumn": 26,
                  "endLine": 324,
                  "endColumn": 30,
                  "charOffset": 10045,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "8c776783-f0ff-305b-82ab-552b39fa1f66",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 319,
                  "startColumn": 48,
                  "endLine": 319,
                  "endColumn": 62,
                  "charOffset": 9938,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(optarg)",
                    "rendered": {
                      "text": "strlen(optarg)",
                      "markdown": "`strlen(optarg)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9938,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9938,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c3e5f9ba-c15a-34f0-9201-7a9e2e53342d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 314,
                  "startColumn": 22,
                  "endLine": 314,
                  "endColumn": 26,
                  "charOffset": 9809,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "f8a65901-b084-3031-b427-923f685177bb",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 304,
                  "startColumn": 29,
                  "endLine": 304,
                  "endColumn": 33,
                  "charOffset": 9600,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "2d364472-da6b-34b1-9c15-ee6bbe4b2598",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 299,
                  "startColumn": 30,
                  "endLine": 299,
                  "endColumn": 34,
                  "charOffset": 9494,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "81dbaff4-95d0-3e61-9921-7deb3c40a79c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 289,
                  "startColumn": 25,
                  "endLine": 289,
                  "endColumn": 29,
                  "charOffset": 9270,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "e2c7d5ed-7db2-3fda-8f80-d0a6339e9da8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 284,
                  "startColumn": 30,
                  "endLine": 284,
                  "endColumn": 34,
                  "charOffset": 9168,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "a7692905-3771-3416-966a-7b1d4e8a0a9e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 269,
                  "startColumn": 24,
                  "endLine": 269,
                  "endColumn": 28,
                  "charOffset": 8852,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "24ab890a-c55a-33ed-952a-7adff6d4a167",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 262,
                  "startColumn": 10,
                  "endLine": 262,
                  "endColumn": 14,
                  "charOffset": 8671,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "5e38f064-f633-3c39-811e-5584912118a7",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 249,
                  "startColumn": 10,
                  "endLine": 249,
                  "endColumn": 14,
                  "charOffset": 8381,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "efacfc8b-173e-303f-adb3-d67aa6346442",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 238,
                  "startColumn": 32,
                  "endLine": 238,
                  "endColumn": 36,
                  "charOffset": 8140,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "a54dd078-0b74-3e95-a2ea-156a49004713",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 233,
                  "startColumn": 38,
                  "endLine": 233,
                  "endColumn": 42,
                  "charOffset": 8023,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "0d16502c-dac1-343a-8e9a-9ea348d9583b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 228,
                  "startColumn": 26,
                  "endLine": 228,
                  "endColumn": 30,
                  "charOffset": 7903,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "fdbe6aa7-0ddf-3415-8463-4a69dcc9e504",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 213,
                  "startColumn": 47,
                  "endLine": 213,
                  "endColumn": 61,
                  "charOffset": 7592,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(optarg)",
                    "rendered": {
                      "text": "strlen(optarg)",
                      "markdown": "`strlen(optarg)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7592,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7592,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7810f9db-7e92-3ebd-be8d-4010dd6c6b0d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 209,
                  "startColumn": 44,
                  "endLine": 209,
                  "endColumn": 58,
                  "charOffset": 7487,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(optarg)",
                    "rendered": {
                      "text": "strlen(optarg)",
                      "markdown": "`strlen(optarg)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7487,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7487,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "4847d334-a37c-3472-919a-f08904d95f94",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/ibverbs/address.cc"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 2,
                  "endLine": 32,
                  "endColumn": 44,
                  "charOffset": 688,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(bytes.data(), &addr_, sizeof(addr_)",
                    "rendered": {
                      "text": "memcpy(bytes.data(), &addr_, sizeof(addr_)",
                      "markdown": "`memcpy(bytes.data(), &addr_, sizeof(addr_)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/ibverbs/address.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 688,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(bytes.data(), <size of bytes.data()>,  &addr_,  sizeof(addr_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a9811300-2dc0-3a94-a43f-ba712fe27b8b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 201,
                  "startColumn": 47,
                  "endLine": 201,
                  "endColumn": 61,
                  "charOffset": 7303,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(optarg)",
                    "rendered": {
                      "text": "strlen(optarg)",
                      "markdown": "`strlen(optarg)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7303,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/benchmark/options.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7303,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(optarg, <size of optarg>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "9d8be6d3-e2ac-335a-b9c4-533c4b1541d0",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 205,
                  "startColumn": 27,
                  "endLine": 205,
                  "endColumn": 31,
                  "charOffset": 7388,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "b42dc0bb-aaf4-31da-96ac-52e576a75c3c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Win32 - Hard-coded SSL/TLS Protocol"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/tls/openssl.h"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 5,
                  "endLine": 32,
                  "endColumn": 31,
                  "charOffset": 773,
                  "charLength": 26,
                  "snippet": {
                    "text": "SSL_CTX_set_security_level",
                    "rendered": {
                      "text": "SSL_CTX_set_security_level",
                      "markdown": "`SSL_CTX_set_security_level`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.Protocol.TLS.Hard-Coded"
            ]
          }
        },
        {
          "ruleId": "814b18fa-c7ae-30cc-bfac-593dcf0b1c71",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/scatter.cc"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 4,
                  "endLine": 48,
                  "endColumn": 55,
                  "charOffset": 1334,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(out->ptr, in[context->rank]->ptr, out->size)",
                    "rendered": {
                      "text": "memcpy(out->ptr, in[context->rank]->ptr, out->size)",
                      "markdown": "`memcpy(out->ptr, in[context->rank]->ptr, out->size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/scatter.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1334,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out->ptr, <size of out->ptr>,  in[context->rank]->ptr,  out->size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e7aa8d31-6ac7-3e92-9c9b-7a898e06ce46",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Win32 - Hard-coded SSL/TLS Protocol"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/tls/openssl.h"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 18,
                  "endLine": 20,
                  "endColumn": 28,
                  "charOffset": 473,
                  "charLength": 10,
                  "snippet": {
                    "text": "TLS_method",
                    "rendered": {
                      "text": "TLS_method",
                      "markdown": "`TLS_method`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.Protocol.TLS.Hard-Coded"
            ]
          }
        },
        {
          "ruleId": "7bdbca30-24e7-327c-99e4-879c4effe401",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Win32 - Hard-coded SSL/TLS Protocol"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/tcp/tls/openssl.h"
                },
                "region": {
                  "startLine": 22,
                  "startColumn": 9,
                  "endLine": 22,
                  "endColumn": 20,
                  "charOffset": 501,
                  "charLength": 11,
                  "snippet": {
                    "text": "SSL_CTX_new",
                    "rendered": {
                      "text": "SSL_CTX_new",
                      "markdown": "`SSL_CTX_new`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.Protocol.TLS.Hard-Coded"
            ]
          }
        },
        {
          "ruleId": "f888df33-e53b-32bd-9ada-751951bfe76a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/ibverbs/address.cc"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 2,
                  "endLine": 27,
                  "endColumn": 44,
                  "charOffset": 553,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(&addr_, bytes.data(), sizeof(addr_)",
                    "rendered": {
                      "text": "memcpy(&addr_, bytes.data(), sizeof(addr_)",
                      "markdown": "`memcpy(&addr_, bytes.data(), sizeof(addr_)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "gloo/transport/ibverbs/address.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 553,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&addr_, <size of &addr_>,  bytes.data(),  sizeof(addr_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c7d97622-b1ff-392c-86e3-92511e584f26",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 197,
                  "startColumn": 29,
                  "endLine": 197,
                  "endColumn": 33,
                  "charOffset": 7201,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "ab8929f6-6b17-3a0c-bf43-f8532908fa4c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/benchmark/options.cc"
                },
                "region": {
                  "startLine": 193,
                  "startColumn": 29,
                  "endLine": 193,
                  "endColumn": 33,
                  "charOffset": 7117,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "0e935b3e-3916-32a7-be68-7c7e3069fa49",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/ibverbs/buffer.cc"
                },
                "region": {
                  "startLine": 59,
                  "startColumn": 47,
                  "endLine": 59,
                  "endColumn": 55,
                  "charOffset": 1481,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "1c19a17a-d0b2-3ead-95ed-ec96e7cb77e9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/ibverbs/buffer.cc"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 6,
                  "endLine": 55,
                  "endColumn": 14,
                  "charOffset": 1357,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "9d6b3b2b-4710-39d8-9f80-14973da4d408",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gloo/transport/ibverbs/buffer.cc"
                },
                "region": {
                  "startLine": 44,
                  "startColumn": 8,
                  "endLine": 44,
                  "endColumn": 16,
                  "charOffset": 1070,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}